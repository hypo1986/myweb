<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Generator函数的特征及应用小实例</title>
    <url>/blog/2019/07/12/2019-07-12-generator/</url>
    <content><![CDATA[<p>很多人都知道promise,很多人却不知道Generator是个啥，啥时候用的到，看了一些文档我认为Generator是一个很重要的东西，需要认真理解一下。想看更详细文档可以去阮一峰大师的es6文档去看。</p>
<h1 id="一、Generator-函数简介"><a href="#一、Generator-函数简介" class="headerlink" title="一、Generator 函数简介"></a>一、Generator 函数简介</h1><p>1、Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<p>2、Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>3、执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<a id="more"></a>
<h1 id="二、Generator-函数特征"><a href="#二、Generator-函数特征" class="headerlink" title="二、Generator 函数特征"></a>二、Generator 函数特征</h1><h4 id="两个特征："><a href="#两个特征：" class="headerlink" title="两个特征："></a>两个特征：</h4><p>1、function关键字与函数名之间有一个星号<br>2、函数体内部使用yield表达式，定义不同的内部状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* helloWorldGenerator() &#123;</span><br><span class="line">  yield &apos;hello&apos;;</span><br><span class="line">  yield &apos;world&apos;;</span><br><span class="line">  return &apos;ending&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<h4 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h4><p>1、调用 Generator 函数后，该函数并不执行<br>2、返回的也不是函数运行结果，而是一个指向内部状态的指针对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw.next()</span><br><span class="line">// &#123; value: &apos;hello&apos;, done: false &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: &apos;world&apos;, done: false &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: &apos;ending&apos;, done: true &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<h4 id="for…of-循环："><a href="#for…of-循环：" class="headerlink" title="for…of 循环："></a>for…of 循环：</h4><p>for…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">  yield 4;</span><br><span class="line">  yield 5;</span><br><span class="line">  return 6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let v of foo()) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// 1 2 3 4 5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1</span><br><span class="line">  yield 2</span><br><span class="line">  return 3</span><br><span class="line">  yield 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扩展运算符</span><br><span class="line">[...numbers()] // [1, 2]</span><br><span class="line"></span><br><span class="line">// Array.from 方法</span><br><span class="line">Array.from(numbers()) // [1, 2]</span><br><span class="line"></span><br><span class="line">// 解构赋值</span><br><span class="line">let [x, y] = numbers();</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">// for...of 循环</span><br><span class="line">for (let n of numbers()) &#123;</span><br><span class="line">  console.log(n)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>

<h4 id="yield-表达式："><a href="#yield-表达式：" class="headerlink" title="yield* 表达式："></a>yield* 表达式：</h4><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* iterTree(tree) &#123;</span><br><span class="line">  if (Array.isArray(tree)) &#123;</span><br><span class="line">    for(let i=0; i &lt; tree.length; i++) &#123;</span><br><span class="line">      yield* iterTree(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    yield tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const tree = [ &apos;a&apos;, [&apos;b&apos;, &apos;c&apos;], [&apos;d&apos;, &apos;e&apos;] ];</span><br><span class="line"></span><br><span class="line">for(let x of iterTree(tree)) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// a</span><br><span class="line">// b</span><br><span class="line">// c</span><br><span class="line">// d</span><br><span class="line">// e</span><br></pre></td></tr></table></figure>

<h1 id="三、Generator-函数应用"><a href="#三、Generator-函数应用" class="headerlink" title="三、Generator 函数应用"></a>三、Generator 函数应用</h1><h4 id="异步操作的同步化表达："><a href="#异步操作的同步化表达：" class="headerlink" title="异步操作的同步化表达："></a>异步操作的同步化表达：</h4><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* loadUI() &#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  yield loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line">var loader = loadUI();</span><br><span class="line">// 加载UI</span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line">// 卸载UI</span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure>

<h4 id="控制流管理："><a href="#控制流管理：" class="headerlink" title="控制流管理："></a>控制流管理：</h4><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step1(function (value1) &#123;</span><br><span class="line">  step2(value1, function(value2) &#123;</span><br><span class="line">    step3(value2, function(value3) &#123;</span><br><span class="line">      step4(value3, function(value4) &#123;</span><br><span class="line">        // Do something with value4</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>采用 Promise 改写上面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(step1)</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4)</span><br><span class="line">  .then(function (value4) &#123;</span><br><span class="line">    // Do something with value4</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    // Handle any error from step1 through step4</span><br><span class="line">  &#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure>

<p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* longRunningTask(value1) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var value2 = yield step1(value1);</span><br><span class="line">    var value3 = yield step2(value2);</span><br><span class="line">    var value4 = yield step3(value3);</span><br><span class="line">    var value5 = yield step4(value4);</span><br><span class="line">    // Do something with value4</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // Handle any error from step1 through step4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，使用一个函数，按次序自动执行所有步骤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheduler(longRunningTask(initialValue));</span><br><span class="line"></span><br><span class="line">function scheduler(task) &#123;</span><br><span class="line">  var taskObj = task.next(task.value);</span><br><span class="line">  // 如果Generator函数未结束，就继续调用</span><br><span class="line">  if (!taskObj.done) &#123;</span><br><span class="line">    task.value = taskObj.value</span><br><span class="line">    scheduler(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="async-函数："><a href="#async-函数：" class="headerlink" title="async 函数："></a>async 函数：</h4><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function asyncPrint(value, ms) &#123;</span><br><span class="line">  await timeout(ms);</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(&apos;hello world&apos;, 50);</span><br></pre></td></tr></table></figure>

<h4 id="async-函数优点："><a href="#async-函数优点：" class="headerlink" title="async 函数优点："></a>async 函数优点：</h4><p>1、<strong>内置执行器</strong><br>Generator 函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。这完全不像 Generator 函数，需要调用next方法，才能真正执行，得到最后结果。</p>
<p>2、<strong>更好的语义</strong><br>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<p>3、<strong>更广的适用性</strong><br>yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）</p>
<p>4、<strong>返回 Promise</strong><br>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p>
<h1 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h1><h4 id="抽奖"><a href="#抽奖" class="headerlink" title="抽奖"></a>抽奖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;starts()&quot;&gt;抽奖&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  //定义一个普通函数,输出剩余次数</span><br><span class="line">  let draw = function (count) &#123;</span><br><span class="line">      alert(`剩余 $&#123;count&#125; 次`)</span><br><span class="line">  &#125;</span><br><span class="line">  //定义一个Generator函数，接收一个count参数，每次调用都减少1</span><br><span class="line">  let resize = function* (count) &#123;</span><br><span class="line">      while (count &gt; 0)&#123;</span><br><span class="line">          count -- ;</span><br><span class="line">          yield draw(count) //调用draw函数，输出count</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //调用resize 函数，初始化count为5，此时resize 函数并不会执行。</span><br><span class="line">  let start = resize(5);</span><br><span class="line">  function starts() &#123;</span><br><span class="line">      start.next()//通过点击按钮，调用resize 的next方法执行函数体，执行一次便暂停一次</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="长轮训"><a href="#长轮训" class="headerlink" title="长轮训"></a>长轮训</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ajax = function* () &#123;</span><br><span class="line">    yield new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            resolve(&#123;code:1&#125;)</span><br><span class="line">        &#125;,500)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let pull = function () &#123;</span><br><span class="line">    let genertaor = ajax();</span><br><span class="line">    let step = genertaor.next();</span><br><span class="line">    step.value.then(function (res) &#123;</span><br><span class="line">        if(res.code != 0)&#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                pull();</span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">pull();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>js正则表达式理解与实例</title>
    <url>/blog/2019/08/05/2019-08-05-javascript-regexp/</url>
    <content><![CDATA[<p>作为一名代码开发者，我认为基础是最重要的，不要说我会用什么什么流行框架，那将很快过时。但是如果你基础很好，不论什么新鲜框架，你都会很快的掌握和运用，或者你可以自己尝试开发一些应用级框架。正则就是js基础必备。</p>
<h1 id="一、js正则简介"><a href="#一、js正则简介" class="headerlink" title="一、js正则简介"></a>一、js正则简介</h1><p>正则表达式是对字符串执行模式匹配的强大工具。</p>
<h4 id="创建一个正则"><a href="#创建一个正则" class="headerlink" title="创建一个正则"></a>创建一个正则</h4><p>第一种：字面量创建，将正则表达式直接当做对象使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cc = /[a-z]/;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>第二种：实例化RegExp对象方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cc = new RegExp(&apos;[a-z]&apos;);</span><br></pre></td></tr></table></figure>

<h4 id="前例"><a href="#前例" class="headerlink" title="前例"></a>前例</h4><p>十八位身份证校验：</p>
<p>前六位：[1-9]\d{5}<br>年份（1900-2099）(19|20)\d{2}<br>月日（例子上的是闰年，如果平年的话把后面的02(0[1-9]|[1-2][0-9])改成02(0[1-9]|1[0-9]|2[0-8])即可）：( (01|03|05|07|08|10|12)(0[1-9]|[1,2][0-9]|3[0-1]) | (04|06|07|11)(0[1-9]|[1,2][0-9]|30) | 02(0[1-9]|[1-2][0-9]) )<br>三位顺序码：[0-9]{3}<br>校验码（0-9或者X或者x）:[0-9Xx]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pattern = /^[1-9]\d&#123;5&#125;(19|20)\d&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|07|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$/;</span><br><span class="line">var str = &apos;23333319990223283X&apos;;</span><br><span class="line">pattern.test(str); //true</span><br></pre></td></tr></table></figure>

<h1 id="二、js正则基础知识点"><a href="#二、js正则基础知识点" class="headerlink" title="二、js正则基础知识点"></a>二、js正则基础知识点</h1><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>i : 执行对大小写不敏感的匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new RegExp(&quot;regexp&quot;,&quot;i&quot;)</span><br><span class="line">/regexp/i</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &quot;Visit W3School&quot;;</span><br><span class="line">var patt1 = /w3school/i;</span><br><span class="line">str.match(patt1); //W3School</span><br></pre></td></tr></table></figure>

<p>g : 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</p>
<p>对 “is” 进行全局搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this all there is?&quot;;</span><br><span class="line">var patt1=/is/g;</span><br><span class="line">str.match(patt1); //is,is</span><br></pre></td></tr></table></figure>

<p>对 “is” 进行全局且大小写不敏感的搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this all there is?&quot;;</span><br><span class="line">var patt1=/is/gi;</span><br><span class="line">str.match(patt1); //Is,is,is</span><br></pre></td></tr></table></figure>

<h4 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h4><p>方括号用于查找某个范围内的字符：</p>
<p>[abc] : 查找方括号之间的任何字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this all there is?&quot;;</span><br><span class="line">var patt1=/[a-h]/g;</span><br><span class="line">str.match(patt1); //h,a,h,e,e</span><br></pre></td></tr></table></figure>

<p>[^abc] : 查找任何不在方括号之间的字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this all there is?&quot;;</span><br><span class="line">var patt1=/[^a-h]/g;</span><br><span class="line">str.match(patt1); //I,s, ,t,i,s, ,l,l, ,t,r, ,i,s,?</span><br></pre></td></tr></table></figure>

<p>[0-9] : 查找任何从 0 至 9 的数字。<br>[a-z] : 查找任何从小写 a 到小写 z 的字符。<br>[A-Z] : 查找任何从大写 A 到大写 Z 的字符。<br>[A-z] : 查找任何从大写 A 到小写 z 的字符。<br>(red|blue|green) : 查找任何指定的选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this all there is?&quot;;</span><br><span class="line">var patt1=/[ah]/g;</span><br><span class="line">var patt2=/(a|h)/g;</span><br><span class="line">str.match(patt1); //h,a,h</span><br><span class="line">str.match(patt2); //h,a,h</span><br></pre></td></tr></table></figure>

<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>元字符（Metacharacter）是拥有特殊含义的字符：</p>
<p>. : 查找单个字符，除了换行和行结束符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;That&apos;s hot!&quot;;</span><br><span class="line">var patt1=/h.t/g;</span><br><span class="line">str.match(patt1); //hat,hot</span><br></pre></td></tr></table></figure>

<p>\w : 查找单词字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Give 100%!&quot;; </span><br><span class="line">var patt1=/\w/g;</span><br><span class="line">str.match(patt1); //G,i,v,e,1,0,0</span><br></pre></td></tr></table></figure>

<p>穿插小例子: 邮箱验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re=/^\w+@[a-z0-9]+\.[a-z]+$/i; //邮箱不区分大小写</span><br><span class="line">re.test(&apos;aa@12.com&apos;); //true</span><br><span class="line">re.test(&apos;a.a@12.com&apos;); //false</span><br></pre></td></tr></table></figure>

<p>\W : 查找非单词字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Give 100%!&quot;; </span><br><span class="line">var patt1=/\W/g;</span><br><span class="line">str.match(patt1); // ,%,!</span><br></pre></td></tr></table></figure>

<p>\d : 查找数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Give 100%!&quot;; </span><br><span class="line">var patt1=/\d/g;</span><br><span class="line">str.match(patt1); //1,0,0</span><br></pre></td></tr></table></figure>

<p>\D : 查找非数字字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Give 100%!&quot;; </span><br><span class="line">var patt1=/\D/g;</span><br><span class="line">str.match(patt1); //G,i,v,e, ,%,!</span><br></pre></td></tr></table></figure>

<p>\s : 查找空白字符。<br>\S : 查找非空白字符。</p>
<p>穿插小例子: a标签的匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pattern = /&lt;a\b[^&gt;]+\bhref=&quot;([^&quot;]*)&quot;[^&gt;]*&gt;([\s\S]*?)&lt;\/a&gt;/</span><br><span class="line">var str = &apos;&lt;a title=&quot;title&quot; href=&quot;//www.baidu.com&quot; class=&quot;hh&quot;&gt;&lt;/a&gt;&apos;;</span><br><span class="line">pattern.test(str); //true</span><br></pre></td></tr></table></figure>

<p>解释一下，其中</p>
<p>&lt;a\b 表示匹配a标签的开始，<br>[^&gt;]+ 匹配非&gt;字符的一到多个任意字符<br>\bhref=”([^”]<em>)” 匹配href的值，并且将匹配到的值捕获到分组中<br>[^&gt;]</em> 匹配href后除了&gt;字符0到多个任意字符<br>([\s\S]*?) 匹配任意字符并捕获到组中（包含空格和非空格字符，非贪婪匹配，也可以用.?但是.不能包含空行）</p>
<p>\b : 匹配单词边界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;moon&quot;; </span><br><span class="line">var patt1=/\bm/;</span><br><span class="line">var patt2=/oo\b/;</span><br><span class="line">var patt3=/oon\b/;</span><br><span class="line">var patt4=/\w\b\w/;</span><br><span class="line"></span><br><span class="line">str.match(patt1); //m</span><br><span class="line">str.match(patt2); //null</span><br><span class="line">str.match(patt3); //oon</span><br><span class="line">str.match(patt4); //null</span><br></pre></td></tr></table></figure>

<p>说明：<br>/\bm/ 匹配 “moon” 中的 ‘m’；<br>/oo\b/ 不匹配 “moon” 中的 ‘oo’，因为 ‘oo’ 后面的 ‘n’ 是一个单词字符；<br>/oon\b/ 匹配 “moon” 中的 ‘oon’，因为 ‘oon’ 位于字符串的末端，后面没有单词字符；<br>/\w\b\w/ 不匹配任何字符，因为单词字符之后绝不会同时紧跟着非单词字符和单词字符。</p>
<p>\B : 匹配非单词边界。<br>对字符串中不位于单词开头或结尾的 “School” 进行全局搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Visit W3School&quot;; </span><br><span class="line">var patt1=/\BSchool/g;</span><br><span class="line">str.match(patt1); //School</span><br></pre></td></tr></table></figure>

<p>\n : 查找换行符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Visit W3School.\n Learn JavaScript.&quot;; </span><br><span class="line">var patt1=/\n/g;</span><br><span class="line">str.search(patt1); //15</span><br></pre></td></tr></table></figure>

<p>\uxxxx : 查找以十六进制数 xxxx 规定的 Unicode 字符。<br>对字符串中的十六进制 0057 (W) 进行全局搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Visit W3School. Hello World!&quot;; </span><br><span class="line">var patt1=/\u0057/g;</span><br><span class="line">str.match(patt1); //W,W</span><br></pre></td></tr></table></figure>

<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>n+ : 匹配任何包含至少一个 n 的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Hellooo World! Hello W3School!&quot;; </span><br><span class="line">var patt1=/o+/g;</span><br><span class="line">str.match(patt1); //ooo,o,o,oo</span><br></pre></td></tr></table></figure>

<p>穿插小例子：Email地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*$/</span><br></pre></td></tr></table></figure>

<p>n* : 匹配任何包含零个或多个 n 的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Hellooo World! Hello W3School!&quot;; </span><br><span class="line">var patt1=/lo*/g;</span><br><span class="line">str.match(patt1); //l,looo,l,l,lo,l</span><br></pre></td></tr></table></figure>

<p>n? : 匹配任何包含零个或一个 n 的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;1, 100 or 1000?&quot;; </span><br><span class="line">var patt1=/10?/g;</span><br><span class="line">str.match(patt1); //1,10,10</span><br></pre></td></tr></table></figure>

<p>n{X} : 匹配包含 X 个 n 的序列的字符串。<br>对包含四位数字序列的子串进行全局搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class="line">var patt1=/\d&#123;4&#125;/g; </span><br><span class="line">str.match(patt1); //1000,1000</span><br></pre></td></tr></table></figure>

<p>n{X,Y} : 匹配包含 X 至 Y 个 n 的序列的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class="line">var patt1=/\d&#123;3,4&#125;/g; </span><br><span class="line">str.match(patt1); //100,1000,1000</span><br></pre></td></tr></table></figure>

<p>n{X,} : 匹配包含至少 X 个 n 的序列的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;100, 1000 or 10000?&quot;;</span><br><span class="line">var patt1=/\d&#123;3,&#125;/g; </span><br><span class="line">str.match(patt1); //100,1000,10000</span><br></pre></td></tr></table></figure>

<p>n$ : 匹配任何结尾为 n 的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this his&quot;;</span><br><span class="line">var patt1=/is$/g;</span><br><span class="line">str.match(patt1); // is</span><br><span class="line">patt1.test(str); //true</span><br></pre></td></tr></table></figure>

<p>^n : 匹配任何开头为 n 的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this his&quot;;</span><br><span class="line">var patt1=/^Is/g;</span><br><span class="line">str.match(patt1); //Is</span><br><span class="line">patt1.test(str); //true</span><br></pre></td></tr></table></figure>

<p>?=n : 匹配任何其后紧接指定字符串 n 的字符串。<br>对其后紧跟 “all” 的 “is” 进行全局搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this all there is&quot;;</span><br><span class="line">var patt1=/is(?= all)/;</span><br><span class="line">str.match(patt1); //is</span><br></pre></td></tr></table></figure>

<p>穿插小例子：密码强度正则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</span><br><span class="line">/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$/.test(&quot;weeeeeeeW2&quot;);</span><br><span class="line">//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span><br><span class="line">/^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/.test(&quot;diaoD123#&quot;);</span><br><span class="line">//输出 true</span><br></pre></td></tr></table></figure>

<p>?!n : 匹配任何其后没有紧接指定字符串 n 的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Is this all there is&quot;;</span><br><span class="line">var patt1=/is(?! all)/gi;</span><br><span class="line">str.match(patt1); //Is,is</span><br><span class="line">/^(?!0)\d&#123;4&#125;$/.test(&apos;2019&apos;); //true</span><br><span class="line">/^(?!0)\d&#123;4&#125;$/.test(&apos;0019&apos;); //false</span><br></pre></td></tr></table></figure>

<h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>compile : 编译正则表达式。</p>
<p>在字符串中全局搜索 “man”，并用 “person” 替换。然后通过 compile() 方法，改变正则表达式，用 “person” 替换 “man” 或 “woman” :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Every man in the world! Every woman on earth!&quot;;</span><br><span class="line"></span><br><span class="line">patt=/man/g;</span><br><span class="line">str2=str.replace(patt,&quot;person&quot;);</span><br><span class="line">document.write(str2+&quot;&lt;br /&gt;&quot;);</span><br><span class="line"></span><br><span class="line">patt=/(wo)?man/g;</span><br><span class="line">patt.compile(patt); //改变正则表达式</span><br><span class="line">str2=str.replace(patt,&quot;person&quot;);</span><br><span class="line">document.write(str2);</span><br><span class="line">//输出</span><br><span class="line">Every person in the world! Every woperson on earth!</span><br><span class="line">Every person in the world! Every person on earth!</span><br></pre></td></tr></table></figure>

<p>exec : 检索字符串中指定的值。返回找到的值，并确定其位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &quot;Visit W3School, W3School is a place to study web technology.&quot;; </span><br><span class="line">var patt = new RegExp(&quot;W3School&quot;,&quot;g&quot;);</span><br><span class="line">var result;</span><br><span class="line"></span><br><span class="line">while ((result = patt.exec(str)) != null)  &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">  console.log(patt.lastIndex);</span><br><span class="line"> &#125;</span><br><span class="line">//输出</span><br><span class="line">W3School</span><br><span class="line">14</span><br><span class="line">W3School</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<p>test : 检索字符串中指定的值。返回 true 或 false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pattern = /[hf]ello/g,</span><br><span class="line">    str = &apos;hello&apos;;</span><br><span class="line">pattern.test(str); //true</span><br><span class="line">pattern = /[ef]ello/g;</span><br><span class="line">pattern.test(str); //false</span><br></pre></td></tr></table></figure>

<h4 id="String-对象的方法"><a href="#String-对象的方法" class="headerlink" title="String 对象的方法"></a>String 对象的方法</h4><p>search : 检索与正则表达式相匹配的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Hello world!&quot;</span><br><span class="line">str.search(&quot;world&quot;); //6</span><br><span class="line">str.search(&quot;World&quot;); //-1</span><br><span class="line">str.search(&quot;woorld&quot;); //-1</span><br></pre></td></tr></table></figure>

<p>说明:search() 方法不执行全局匹配，它将忽略标志 g。</p>
<p>match : 找到一个或多个正则表达式的匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Hello world!&quot;</span><br><span class="line">str.match(&quot;world&quot;); //world</span><br><span class="line">str.match(&quot;World&quot;); //null</span><br></pre></td></tr></table></figure>

<p>replace : 替换与正则表达式匹配的子串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;Visit Microsoft!&quot;</span><br><span class="line">str.replace(/Microsoft/,&quot;W3School&quot;); //Visit W3School!</span><br></pre></td></tr></table></figure>

<p>$1、$2、…、$99 : 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name = &quot;Doe, John&quot;;</span><br><span class="line">name.replace(/(\w+)\s*, \s*(\w+)/, &quot;$2 $1&quot;); //John Doe</span><br></pre></td></tr></table></figure>

<p>穿插小例子: 找重复项最多的字符和个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &apos;sassdfdfffdasdffffffsdsdddsss&apos;;</span><br><span class="line">var arr = str.split(&apos;&apos;);//先把字符串分割为字符串数组</span><br><span class="line">str = arr.sort().join(&apos;&apos;);</span><br><span class="line">var value = &apos;&apos;;</span><br><span class="line">var index = 0;</span><br><span class="line">var re = /(\w)\1+/g;</span><br><span class="line">str.replace(re,function($0,$1)&#123;</span><br><span class="line">    if(index&lt;$0.length)&#123;</span><br><span class="line">      index = $0.length;</span><br><span class="line">      value = $1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;最多的字符：&apos;+ value +&apos; ,重复的次数：&apos;+index);</span><br><span class="line">//最多的字符：f ,重复的次数：10</span><br></pre></td></tr></table></figure>

<p>说明：\1 是捕获组，就是第一个小括号内的值（从左向→）</p>
<p>split : 把字符串分割为字符串数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &quot;How are you doing today?&quot;;</span><br><span class="line">str.split(&apos; &apos;); //[&quot;How&quot;, &quot;are&quot;, &quot;you&quot;, &quot;doing&quot;, &quot;today?&quot;]</span><br><span class="line">str.split(&apos; &apos;, 3); //[&quot;How&quot;, &quot;are&quot;, &quot;you&quot;]</span><br></pre></td></tr></table></figure>

<p>对象属性lastIndex : 一个整数，标示开始下一次匹配的字符位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str = &quot;The rain in Spain stays mainly in the plain&quot;;</span><br><span class="line">var patt1 = new RegExp(&quot;ain&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; 4; i++) </span><br><span class="line">&#123;</span><br><span class="line">  patt1.test(str)</span><br><span class="line">  console.log(patt1.lastIndex);</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">8</span><br><span class="line">17</span><br><span class="line">28</span><br><span class="line">43</span><br></pre></td></tr></table></figure>

<p>例子1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;I love antzone ,this is animate&quot;;</span><br><span class="line">var reg=/an/g;</span><br><span class="line">console.log(reg.exec(str)); //[&quot;an&quot;, index: 7, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br><span class="line">console.log(reg.exec(str)); // [&quot;an&quot;, index: 24, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str=&quot;I love antzone ,this is animate&quot;;</span><br><span class="line">var reg=/an/g;</span><br><span class="line">reg.lastIndex = 20</span><br><span class="line">console.log(reg.exec(str)); // [&quot;an&quot;, index: 24, input: &quot;I love antzone ,this is animate&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<h4 id="等价的正则表达式"><a href="#等价的正则表达式" class="headerlink" title="等价的正则表达式"></a>等价的正则表达式</h4><p>常规等价：<br>/\d/ = /[0-9]/ = /[0123456789]//\D/ = /[^\d]/ = /^[0-9]/<br>/\s/ 匹配一个空白字符，等价于/[\n\r\f\t\v]<br>/\S/ 匹配一个非空白字符，等价于/[^\n\f\r\t\v]<br>/\w/ 任何单字字符, 等价于/[a-zA-Z0-9_]//\W/ 任何非单字字符,等价于/[^a-zA-Z0-9_]/<br>// ? 匹配前一项0次或1次,也就是说前一项是可选的. 等价于 {0, 1}<br>// + 匹配前一项1次或多次,等价于{1,}<br>// * 匹配前一项0次或多次.等价于{0,}</p>
<p>其它等价：<br>/^[ab]cd$/.test(“abc”); //true<br>等价于/^(a|b)cd$/.test(“abc”)</p>
<p>转义：’/‘, ‘&#39;, ‘.’ ,’?’等需要被转义字符都符合[char] = \char<br>/^[.]abc/.test(“a.abc”)//true<br>等价于/^.abc/.test(“.abc”)　</p>
<h1 id="三、js正则常用实例"><a href="#三、js正则常用实例" class="headerlink" title="三、js正则常用实例"></a>三、js正则常用实例</h1><h4 id="用户名正则"><a href="#用户名正则" class="headerlink" title="用户名正则"></a>用户名正则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//用户名正则，4到16位（字母，数字，下划线，减号）</span><br><span class="line">/^[a-zA-Z0-9_-]&#123;4,16&#125;$/.test(&quot;diaodiao&quot;);</span><br><span class="line">//输出 true</span><br></pre></td></tr></table></figure>

<h4 id="整数正则"><a href="#整数正则" class="headerlink" title="整数正则"></a>整数正则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^\d+$/.test(&quot;42&quot;);    //正整数正则  -&gt; 输出 true</span><br><span class="line">/^-\d+$/.test(&quot;-42&quot;);  //负整数正则  -&gt; 输出 true</span><br><span class="line">/^-?\d+$/.test(&quot;-42&quot;); //整数正则  -&gt; 输出 true</span><br><span class="line">/^[0-9]+$/.test(25.5455) //正整数正则  -&gt; 输出 false</span><br></pre></td></tr></table></figure>

<h4 id="数字正则"><a href="#数字正则" class="headerlink" title="数字正则"></a>数字正则</h4><p>可以是整数也可以是浮点数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^\d*\.?\d+$/.test(&quot;42.2&quot;);     //正数正则  -&gt; 输出 true</span><br><span class="line">/^-\d*\.?\d+$/.test(&quot;-42.2&quot;);   //负数正则 -&gt; 输出 true</span><br><span class="line">/^-?\d*\.?\d+$/.test(&quot;-42.2&quot;);  //数字正则 -&gt; 输出 true</span><br></pre></td></tr></table></figure>

<h4 id="Email正则"><a href="#Email正则" class="headerlink" title="Email正则"></a>Email正则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Email正则</span><br><span class="line">/^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,4&#125;)$/.test(&quot;wowohoo@qq.com&quot;);</span><br><span class="line">//输出 true</span><br></pre></td></tr></table></figure>

<h4 id="传真号码"><a href="#传真号码" class="headerlink" title="传真号码"></a>传真号码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 国家代码(2到3位)-区号(2到3位)-电话号码(7到8位)-分机号(3位)</span><br><span class="line">/^(([0\+]\d&#123;2,3&#125;-)?(0\d&#123;2,3&#125;)-)(\d&#123;7,8&#125;)(-(\d&#123;3,&#125;))?$/.test(&apos;021-5055455&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="手机号码正则"><a href="#手机号码正则" class="headerlink" title="手机号码正则"></a>手机号码正则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手机号正则</span><br><span class="line">/^1[34578]\d&#123;9&#125;$/.test(&quot;13611778887&quot;);</span><br><span class="line">//输出 true</span><br><span class="line"></span><br><span class="line">//* 国际码 如：中国(+86)</span><br><span class="line">/^((\+?[0-9]&#123;1,4&#125;)|(\(\+86\)))?(13[0-9]|14[57]|15[012356789]|17[03678]|18[0-9])\d&#123;8&#125;$/.test(&quot;13611778887&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="颜色值校验"><a href="#颜色值校验" class="headerlink" title="颜色值校验"></a>颜色值校验</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^#?([0-9a-fA-F]&#123;3&#125;|[0-9a-fA-F]&#123;6&#125;)$/.test(&quot;#ccb2b2&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="清除字符串前后空格的正则表达式"><a href="#清除字符串前后空格的正则表达式" class="headerlink" title="清除字符串前后空格的正则表达式"></a>清除字符串前后空格的正则表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.trim = function()&#123;return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);&#125;</span><br><span class="line">var str2 = &quot; hi space &quot;//这里前后共有两个空格</span><br><span class="line">console.log(str2.length);//14</span><br><span class="line">console.log(str2.trim().length);//8</span><br><span class="line">console.log(str2.trim());//hi space</span><br></pre></td></tr></table></figure>

<h4 id="获取网址url参数转化为键值对"><a href="#获取网址url参数转化为键值对" class="headerlink" title="获取网址url参数转化为键值对"></a>获取网址url参数转化为键值对</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function parseURL(url=window.location.href)&#123;/*es6语法直接设置默认值*/</span><br><span class="line">　　const search = url.substr(url.indexOf(&apos;?&apos;)+1);</span><br><span class="line">　　const obj=&#123;&#125;;</span><br><span class="line">　　search.replace(/([^&amp;=]+)=([^&amp;=]*)/g,function(rs,$1,$2)&#123;</span><br><span class="line">		console.log(rs)</span><br><span class="line">　　　　obj[decodeURIComponent($1)]=decodeURIComponent($2)</span><br><span class="line"></span><br><span class="line">　　&#125;)</span><br><span class="line">　　return obj</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2框架介绍及搭建</title>
    <url>/blog/2019/09/18/2019-09-18-koa2/</url>
    <content><![CDATA[<p>想学会某一项新的技能，最好的方法就是边看文档，边亲自动手实践。<br>亲手搭建基础实例代码 <a href="https://github.com/hypo1986/koa2-demo" target="_blank" rel="noopener">github</a></p>
<h1 id="一、koa简介"><a href="#一、koa简介" class="headerlink" title="一、koa简介"></a>一、koa简介</h1><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p>
<h1 id="二、koa2的优势"><a href="#二、koa2的优势" class="headerlink" title="二、koa2的优势"></a>二、koa2的优势</h1><a id="more"></a>
<h4 id="1-express"><a href="#1-express" class="headerlink" title="1. express"></a>1. express</h4><p>虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.get(&apos;/test&apos;, function (req, res) &#123;</span><br><span class="line">    fs.readFile(&apos;/file1&apos;, function (err, data) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            res.status(500).send(&apos;read file1 error&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.readFile(&apos;/file2&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                res.status(500).send(&apos;read file2 error&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            res.type(&apos;text/plain&apos;);</span><br><span class="line">            res.send(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-koa-1-0"><a href="#2-koa-1-0" class="headerlink" title="2. koa 1.0"></a>2. koa 1.0</h4><p>随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.0使用generator实现异步，代码看起来像同步的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var koa = require(&apos;koa&apos;);</span><br><span class="line">var app = koa();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/test&apos;, function *() &#123;</span><br><span class="line">    yield doReadFile1();</span><br><span class="line">    var data = yield doReadFile2();</span><br><span class="line">    this.body = data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h4 id="3-koa-2-0"><a href="#3-koa-2-0" class="headerlink" title="3. koa 2.0"></a>3. koa 2.0</h4><p>随着ES7引入了新的语法糖async和await，JavaScript未来标准的异步代码是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function () &#123;</span><br><span class="line">    var data = await fs.read(&apos;/file1&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>koa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2。koa2的代码看上去像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">    await next();</span><br><span class="line">    var data = await doReadFile();</span><br><span class="line">    ctx.response.type = &apos;text/plain&apos;;</span><br><span class="line">    ctx.response.body = data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="4-中间件的执行顺序"><a href="#4-中间件的执行顺序" class="headerlink" title="4. 中间件的执行顺序"></a>4. 中间件的执行顺序</h4><p>koa的中间件是由generator组成的，这决定了中间件的执行顺序。<br>Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。</p>
<p>koa是从第一个中间件开始执行，遇到<code>next</code>进入下一个中间件，一直执行到最后一个中间件，在逆序，执行上一个中间件<code>next</code>之后的代码，一直到第一个中间件执行结束才发出响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const one = (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(&apos;&gt;&gt; one&apos;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&apos;&lt;&lt; one&apos;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const two = (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(&apos;&gt;&gt; two&apos;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&apos;&lt;&lt; two&apos;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const three = (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(&apos;&gt;&gt; three&apos;);</span><br><span class="line">  next();</span><br><span class="line">  console.log(&apos;&lt;&lt; three&apos;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">app.use(one);</span><br><span class="line">app.use(two);</span><br><span class="line">app.use(three);</span><br><span class="line"> </span><br><span class="line">输出结果：</span><br><span class="line">&gt;&gt; one</span><br><span class="line">&gt;&gt; two</span><br><span class="line">&gt;&gt; three</span><br><span class="line">&lt;&lt; three</span><br><span class="line">&lt;&lt; two</span><br><span class="line">&lt;&lt; one</span><br></pre></td></tr></table></figure>

<h1 id="三、koa2入门及搭建"><a href="#三、koa2入门及搭建" class="headerlink" title="三、koa2入门及搭建"></a>三、koa2入门及搭建</h1><h4 id="1-Context"><a href="#1-Context" class="headerlink" title="1. Context"></a>1. Context</h4><p>Context封装了node中的request和response。</p>
<p><a href="mailto:koa@1.x" target="_blank" rel="noopener">koa@1.x</a>使用this引用Context对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(function *()&#123;</span><br><span class="line">  this.body = &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a href="mailto:koa@2.x" target="_blank" rel="noopener">koa@2.x</a>中使用ctx来访问Context对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  await next();</span><br><span class="line">  ctx.body = &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-创建koa2工程"><a href="#2-创建koa2工程" class="headerlink" title="2. 创建koa2工程"></a>2. 创建koa2工程</h4><p>首先，我们创建一个目录hello-koa并作为工程目录用VS Code打开。然后，我们创建app.js，输入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line"></span><br><span class="line">// 创建一个Koa对象表示web app本身:</span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">// 对于任何请求，app将调用该异步函数处理请求：</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  await next();</span><br><span class="line">  ctx.response.type = &apos;text/html&apos;;</span><br><span class="line">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 在端口3000监听:</span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&apos;app started at port 3000...&apos;);</span><br></pre></td></tr></table></figure>

<p>对于每一个http请求，koa将调用我们传入的异步函数来处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async (ctx, next) =&gt; &#123;</span><br><span class="line">  await next();</span><br><span class="line">  // 设置response的Content-Type:</span><br><span class="line">  ctx.response.type = &apos;text/html&apos;;</span><br><span class="line">  // 设置response的内容:</span><br><span class="line">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数。</p>
<p>上面的异步函数中，我们首先用await next();处理下一个异步函数，然后，设置response的Content-Type和内容。</p>
<p>由async标记的函数称为异步函数，在异步函数中，可以用await调用另一个异步函数，这两个关键字将在ES7中引入。</p>
<p>现在我们遇到第一个问题：koa这个包怎么装，app.js才能正常导入它？</p>
<p>在hello-koa这个目录下创建一个package.json，这个文件描述了我们的hello-koa工程会用到哪些包。完整的文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hello-koa2&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Hello Koa 2 example with async&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;app.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">      &quot;start&quot;: &quot;node app.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">      &quot;koa&quot;,</span><br><span class="line">      &quot;async&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;Apache-2.0&quot;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">      &quot;koa&quot;: &quot;2.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们在hello-koa目录下执行npm install就可以把所需包以及依赖包一次性全部装好。<br>现在，我们的工程结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello-koa/</span><br><span class="line">|</span><br><span class="line">+- app.js &lt;-- 使用koa的js</span><br><span class="line">|</span><br><span class="line">+- package.json &lt;-- 项目描述文件</span><br><span class="line">|</span><br><span class="line">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure>

<p>在控制台执行 npm run start,我们打开浏览器，输入<a href="http://localhost:3000，即可看到效果：" target="_blank" rel="noopener">http://localhost:3000，即可看到效果：</a></p>
<h4 id="3-koa-middleware"><a href="#3-koa-middleware" class="headerlink" title="3. koa middleware"></a>3. koa middleware</h4><p>让我们再仔细看看koa的执行逻辑。核心代码是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  await next();</span><br><span class="line">  ctx.response.type = &apos;text/html&apos;;</span><br><span class="line">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数。</p>
<p>我们可以对ctx操作，并设置返回内容。但是为什么要调用await next()？</p>
<p>原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>
<p>例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(`$&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); // 打印URL</span><br><span class="line">  await next(); // 调用下一个middleware</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  const start = new Date().getTime(); // 当前时间</span><br><span class="line">  await next(); // 调用下一个middleware</span><br><span class="line">  const ms = new Date().getTime() - start; // 耗费时间</span><br><span class="line">  console.log(`Time: $&#123;ms&#125;ms`); // 打印耗费时间</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  await next();</span><br><span class="line">  ctx.response.type = &apos;text/html&apos;;</span><br><span class="line">  ctx.response.body = &apos;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>middleware的顺序很重要，也就是调用app.use()的顺序决定了middleware的顺序。</p>
<p>此外，如果一个middleware没有调用await next()，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  if (await checkUserPermission(ctx)) &#123;</span><br><span class="line">    await next();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ctx.response.status = 403;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>理解了middleware，我们就已经会用koa了！</p>
<p>最后注意ctx对象有一些简写的方法，例如ctx.url相当于ctx.request.url，ctx.type相当于ctx.response.type。</p>
<h1 id="四、处理URL"><a href="#四、处理URL" class="headerlink" title="四、处理URL"></a>四、处理URL</h1><p>在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。<br>正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  if (ctx.request.path === &apos;/&apos;) &#123;</span><br><span class="line">    ctx.response.body = &apos;index page&apos;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    await next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  if (ctx.request.path === &apos;/test&apos;) &#123;</span><br><span class="line">    ctx.response.body = &apos;TEST page&apos;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    await next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  if (ctx.request.path === &apos;/error&apos;) &#123;</span><br><span class="line">    ctx.response.body = &apos;ERROR page&apos;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    await next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这么写是可以运行的，但是好像有点蠢。</p>
<p>应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。</p>
<h4 id="1-koa-router"><a href="#1-koa-router" class="headerlink" title="1. koa-router"></a>1. koa-router</h4><p>为了处理URL，我们需要引入koa-router这个middleware，让它负责处理URL映射。</p>
<p>我们把上一节的hello-koa工程复制一份，重命名为url-koa。</p>
<p>先在package.json中添加依赖项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;koa-router&quot;: &quot;7.0.0&quot;</span><br></pre></td></tr></table></figure>

<p>然后用npm install安装。</p>
<p>接下来，我们修改app.js，使用koa-router来处理URL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line"></span><br><span class="line">// 注意require(&apos;koa-router&apos;)返回的是函数:</span><br><span class="line">const router = require(&apos;koa-router&apos;)();</span><br><span class="line"></span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">// log request URL:</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`);</span><br><span class="line">  await next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// add url-route:</span><br><span class="line">router.get(&apos;/hello/:name&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">  var name = ctx.params.name;</span><br><span class="line">  ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// add router middleware:</span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&apos;app started at port 3000...&apos;);</span><br></pre></td></tr></table></figure>

<p>然后，我们使用router.get(‘/path’, async fn)来注册一个GET请求。可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。</p>
<p>再运行app.js，我们就可以测试不同的URL。</p>
<h4 id="2-处理post请求"><a href="#2-处理post请求" class="headerlink" title="2. 处理post请求"></a>2. 处理post请求</h4><p>用router.get(‘/path’, async fn)处理的是get请求。如果要处理post请求，可以用router.post(‘/path’, async fn)。</p>
<p>用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！</p>
<p>所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到ctx.request.body中。</p>
<p>koa-bodyparser就是用来干这个活的。</p>
<p>我们在package.json中添加依赖项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;koa-bodyparser&quot;: &quot;3.2.0&quot;</span><br></pre></td></tr></table></figure>

<p>然后使用npm install安装。</p>
<p>下面，修改app.js，引入koa-bodyparser：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const bodyParser = require(&apos;koa-bodyparser&apos;);</span><br></pre></td></tr></table></figure>

<p>在合适的位置加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(bodyParser());</span><br></pre></td></tr></table></figure>

<p>由于middleware的顺序很重要，这个koa-bodyparser必须在router之前被注册到app对象上。</p>
<p>现在我们就可以处理post请求了。写一个简单的登录表单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt;</span><br><span class="line">      &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span><br><span class="line">          &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/p&gt;</span><br><span class="line">      &lt;/form&gt;`;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(&apos;/signin&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">  var</span><br><span class="line">    name = ctx.request.body.name || &apos;&apos;,</span><br><span class="line">    password = ctx.request.body.password || &apos;&apos;;</span><br><span class="line">  console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`);</span><br><span class="line">  if (name === &apos;koa&apos; &amp;&amp; password === &apos;12345&apos;) &#123;</span><br><span class="line">    ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意到我们用var name = ctx.request.body.name || ‘’拿到表单的name字段，如果该字段不存在，默认值设置为’’。</p>
<p>类似的，put、delete、head请求也可以由router处理。</p>
<h4 id="3-重构"><a href="#3-重构" class="headerlink" title="3. 重构"></a>3. 重构</h4><p>现在，我们已经可以处理不同的URL了，但是看看app.js，总觉得还是有点不对劲。</p>
<p>所有的URL处理函数都放到app.js里显得很乱，而且，每加一个URL，就需要修改app.js。随着URL越来越多，app.js就会越来越长。</p>
<p>如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让app.js自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+- controllers/</span><br><span class="line">|  |</span><br><span class="line">|  +- login.js &lt;-- 处理login相关URL</span><br><span class="line">|  |</span><br><span class="line">|  +- users.js &lt;-- 处理用户管理相关URL</span><br><span class="line">|</span><br><span class="line">+- app.js &lt;-- 使用koa的js</span><br><span class="line">|</span><br><span class="line">+- package.json &lt;-- 项目描述文件</span><br><span class="line">|</span><br><span class="line">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure>

<p>我们先在controllers目录下编写index.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn_index = async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.response.body = `&lt;h1&gt;Index&lt;/h1&gt;</span><br><span class="line">      &lt;form action=&quot;/signin&quot; method=&quot;post&quot;&gt;</span><br><span class="line">          &lt;p&gt;Name: &lt;input name=&quot;name&quot; value=&quot;koa&quot;&gt;&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;Password: &lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/p&gt;</span><br><span class="line">      &lt;/form&gt;`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fn_signin = async (ctx, next) =&gt; &#123;</span><br><span class="line">  var</span><br><span class="line">    name = ctx.request.body.name || &apos;&apos;,</span><br><span class="line">    password = ctx.request.body.password || &apos;&apos;;</span><br><span class="line">  console.log(`signin with name: $&#123;name&#125;, password: $&#123;password&#125;`);</span><br><span class="line">  if (name === &apos;koa&apos; &amp;&amp; password === &apos;12345&apos;) &#123;</span><br><span class="line">    ctx.response.body = `&lt;h1&gt;Welcome, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ctx.response.body = `&lt;h1&gt;Login failed!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Try again&lt;/a&gt;&lt;/p&gt;`;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  &apos;GET /&apos;: fn_index,</span><br><span class="line">  &apos;POST /signin&apos;: fn_signin</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个index.js通过module.exports把两个URL处理函数暴露出来。</p>
<p>类似的，hello.js把一个URL处理函数暴露出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn_hello = async (ctx, next) =&gt; &#123;</span><br><span class="line">  var name = ctx.params.name;</span><br><span class="line">  ctx.response.body = `&lt;h1&gt;Hello, $&#123;name&#125;!&lt;/h1&gt;`;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  &apos;GET /hello/:name&apos;: fn_hello</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，我们修改app.js，让它自动扫描controllers目录，找到所有js文件，导入，然后注册每个URL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 先导入fs模块，然后用readdirSync列出文件</span><br><span class="line">// 这里可以用sync是因为启动时只运行一次，不存在性能问题:</span><br><span class="line">var files = fs.readdirSync(__dirname + &apos;/controllers&apos;);</span><br><span class="line"></span><br><span class="line">// 过滤出.js文件:</span><br><span class="line">var js_files = files.filter((f)=&gt;&#123;</span><br><span class="line">  return f.endsWith(&apos;.js&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 处理每个js文件:</span><br><span class="line">for (var f of js_files) &#123;</span><br><span class="line">  console.log(`process controller: $&#123;f&#125;...`);</span><br><span class="line">  // 导入js文件:</span><br><span class="line">  let mapping = require(__dirname + &apos;/controllers/&apos; + f);</span><br><span class="line">  for (var url in mapping) &#123;</span><br><span class="line">    if (url.startsWith(&apos;GET &apos;)) &#123;</span><br><span class="line">      // 如果url类似&quot;GET xxx&quot;:</span><br><span class="line">      var path = url.substring(4);</span><br><span class="line">      router.get(path, mapping[url]);</span><br><span class="line">      console.log(`register URL mapping: GET $&#123;path&#125;`);</span><br><span class="line">    &#125; else if (url.startsWith(&apos;POST &apos;)) &#123;</span><br><span class="line">      // 如果url类似&quot;POST xxx&quot;:</span><br><span class="line">      var path = url.substring(5);</span><br><span class="line">      router.post(path, mapping[url]);</span><br><span class="line">      console.log(`register URL mapping: POST $&#123;path&#125;`);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 无效的URL:</span><br><span class="line">      console.log(`invalid URL: $&#123;url&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面的大段代码看起来还是有点费劲，那就把它拆成更小单元的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addMapping(router, mapping) &#123;</span><br><span class="line">  for (var url in mapping) &#123;</span><br><span class="line">    if (url.startsWith(&apos;GET &apos;)) &#123;</span><br><span class="line">      var path = url.substring(4);</span><br><span class="line">      router.get(path, mapping[url]);</span><br><span class="line">      console.log(`register URL mapping: GET $&#123;path&#125;`);</span><br><span class="line">    &#125; else if (url.startsWith(&apos;POST &apos;)) &#123;</span><br><span class="line">      var path = url.substring(5);</span><br><span class="line">      router.post(path, mapping[url]);</span><br><span class="line">      console.log(`register URL mapping: POST $&#123;path&#125;`);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.log(`invalid URL: $&#123;url&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addControllers(router) &#123;</span><br><span class="line">  var files = fs.readdirSync(__dirname + &apos;/controllers&apos;);</span><br><span class="line">  var js_files = files.filter((f) =&gt; &#123;</span><br><span class="line">      return f.endsWith(&apos;.js&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  for (var f of js_files) &#123;</span><br><span class="line">      console.log(`process controller: $&#123;f&#125;...`);</span><br><span class="line">      let mapping = require(__dirname + &apos;/controllers/&apos; + f);</span><br><span class="line">      addMapping(router, mapping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addControllers(router);</span><br></pre></td></tr></table></figure>

<p>确保每个函数功能非常简单，一眼能看明白，是代码可维护的关键。</p>
<h4 id="Controller-Middleware"><a href="#Controller-Middleware" class="headerlink" title="Controller Middleware"></a>Controller Middleware</h4><p>最后，我们把扫描controllers目录和创建router的代码从app.js中提取出来，作为一个简单的middleware使用，命名为controller.js：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">function addMapping(router, mapping) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addControllers(router, dir) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = function (dir) &#123;</span><br><span class="line">  let</span><br><span class="line">      controllers_dir = dir || &apos;controllers&apos;, // 如果不传参数，扫描目录默认为&apos;controllers&apos;</span><br><span class="line">      router = require(&apos;koa-router&apos;)();</span><br><span class="line">  addControllers(router, controllers_dir);</span><br><span class="line">  return router.routes();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们在app.js的代码又简化了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">// 导入controller middleware:</span><br><span class="line">const controller = require(&apos;./controller&apos;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 使用middleware:</span><br><span class="line">app.use(controller());</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>经过重新整理后的工程url2-koa目前具备非常好的模块化，所有处理URL的函数按功能组存放在controllers目录，今后我们也只需要不断往这个目录下加东西就可以了，app.js保持不变。</p>
<h1 id="五、使用Nunjucks模板引擎"><a href="#五、使用Nunjucks模板引擎" class="headerlink" title="五、使用Nunjucks模板引擎"></a>五、使用Nunjucks模板引擎</h1><p>模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。<br>有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？<br>因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。<br>输出HTML有几个特别重要的问题需要考虑：</p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>对特殊字符要转义，避免受到XSS攻击。比如，如果变量name的值不是小明，而是小明<script>...</script>，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。</p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>对不同类型的变量要格式化，比如，货币需要变成12,345.00这样的格式，日期需要变成2016-01-01这样的格式。</p>
<h4 id="简单逻辑"><a href="#简单逻辑" class="headerlink" title="简单逻辑"></a>简单逻辑</h4><p>模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; name &#125;&#125;同学，</span><br><span class="line">&#123;% if score &gt;= 90 %&#125;</span><br><span class="line">    成绩优秀，应该奖励</span><br><span class="line">&#123;% elif score &gt;=60 %&#125;</span><br><span class="line">    成绩良好，继续努力</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    不及格，建议回家打屁股</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。</p>
<h4 id="Nunjucks"><a href="#Nunjucks" class="headerlink" title="Nunjucks"></a>Nunjucks</h4><p>我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。</p>
<p>虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function render(view, model) &#123;</span><br><span class="line">    // TODO:...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，view是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。model就是数据，在JavaScript中，它就是一个简单的Object。render函数返回一个字符串，就是模板的输出。</p>
<p>下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。</p>
<p>我们创建一个use-nunjucks的VS Code工程结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use-nunjucks/</span><br><span class="line">|</span><br><span class="line">+- views/</span><br><span class="line">|  |</span><br><span class="line">|  +- hello.html &lt;-- HTML模板文件</span><br><span class="line">|</span><br><span class="line">+- app.js &lt;-- 入口js</span><br><span class="line">|</span><br><span class="line">+- package.json &lt;-- 项目描述文件</span><br><span class="line">|</span><br><span class="line">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure>

<p>其中，模板文件存放在views目录中。</p>
<p>我们先在package.json中添加nunjucks的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;nunjucks&quot;: &quot;2.4.2&quot;</span><br></pre></td></tr></table></figure>

<p>注意，模板引擎是可以独立使用的，并不需要依赖koa。用npm install安装所有依赖包。</p>
<p>紧接着，我们要编写使用Nunjucks的函数render。怎么写？方法是查看<a href="http://mozilla.github.io/nunjucks/" target="_blank" rel="noopener">Nunjucks</a>的官方文档，仔细阅读后，在app.js中编写代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const nunjucks = require(&apos;nunjucks&apos;);</span><br><span class="line"></span><br><span class="line">function createEnv(path, opts) &#123;</span><br><span class="line">    var</span><br><span class="line">        autoescape = opts.autoescape === undefined ? true : opts.autoescape,</span><br><span class="line">        noCache = opts.noCache || false,</span><br><span class="line">        watch = opts.watch || false,</span><br><span class="line">        throwOnUndefined = opts.throwOnUndefined || false,</span><br><span class="line">        env = new nunjucks.Environment(</span><br><span class="line">            new nunjucks.FileSystemLoader(&apos;views&apos;, &#123;</span><br><span class="line">                noCache: noCache,</span><br><span class="line">                watch: watch,</span><br><span class="line">            &#125;), &#123;</span><br><span class="line">                autoescape: autoescape,</span><br><span class="line">                throwOnUndefined: throwOnUndefined</span><br><span class="line">            &#125;);</span><br><span class="line">    if (opts.filters) &#123;</span><br><span class="line">        for (var f in opts.filters) &#123;</span><br><span class="line">            env.addFilter(f, opts.filters[f]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var env = createEnv(&apos;views&apos;, &#123;</span><br><span class="line">    watch: true,</span><br><span class="line">    filters: &#123;</span><br><span class="line">        hex: function (n) &#123;</span><br><span class="line">            return &apos;0x&apos; + n.toString(16);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>变量env就表示Nunjucks模板引擎对象，它有一个render(view, model)方法，正好传入view和model两个参数，并返回字符串。</p>
<p>创建env需要的参数可以查看文档获知。我们用autoescape = opts.autoescape &amp;&amp; true这样的代码给每个参数加上默认值，最后使用new nunjucks.FileSystemLoader(‘views’)创建一个文件系统加载器，从views目录读取模板。</p>
<p>我们编写一个hello.html模板文件，放到views目录下，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>然后，我们就可以用下面的代码来渲染这个模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s = env.render(&apos;hello.html&apos;, &#123; name: &apos;小明&apos; &#125;);</span><br><span class="line">console.log(s);</span><br></pre></td></tr></table></figure>

<p>获得输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;Hello 小明&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s = env.render(&apos;hello.html&apos;, &#123; name: &apos;&lt;script&gt;alert(&quot;小明&quot;)&lt;/script&gt;&apos; &#125;);</span><br><span class="line">console.log(s);</span><br></pre></td></tr></table></figure>

<p>获得输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;Hello &amp;lt;script&amp;gt;alert(&quot;小明&quot;)&amp;lt;/script&amp;gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>这样就避免了输出恶意脚本。</p>
<p>此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 循环输出名字 --&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;Fruits List&lt;/h3&gt;</span><br><span class="line">    &#123;% for f in fruits %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; f &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>Nunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。</p>
<p>更好的方式是使用继承。先定义一个基本的网页框架base.html：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">&#123;% block header %&#125; &lt;h3&gt;Unnamed&lt;/h3&gt; &#123;% endblock %&#125;</span><br><span class="line">&#123;% block body %&#125; &lt;div&gt;No body&lt;/div&gt; &#123;% endblock %&#125;</span><br><span class="line">&#123;% block footer %&#125; &lt;div&gt;copyright&lt;/div&gt; &#123;% endblock %&#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>base.html定义了三个可编辑的块，分别命名为header、body和footer。子模板可以有选择地对块进行重新定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &apos;base.html&apos; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;&lt;h1&gt;&#123;&#123; header &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block body %&#125;&lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们对子模板进行渲染：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(env.render(&apos;extend.html&apos;, &#123;</span><br><span class="line">    header: &apos;Hello&apos;,</span><br><span class="line">    body: &apos;bla bla bla...&apos;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>输出HTML如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;bla bla bla...&lt;/p&gt;</span><br><span class="line">&lt;div&gt;copyright&lt;/div&gt; &lt;-- footer没有重定义，所以仍使用父模板的内容</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>最后我们要考虑一下Nunjucks的性能。</p>
<p>对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。</p>
<p>性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。</p>
<p>好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了noCache: false这个参数。</p>
<p>在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。</p>
<p>Nunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。</p>
<h1 id="六、使用MVC"><a href="#六、使用MVC" class="headerlink" title="六、使用MVC"></a>六、使用MVC</h1><p>我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！</p>
<p>当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctx.render(&apos;home.html&apos;, &#123; name: &apos;Michael&apos; &#125;);</span><br></pre></td></tr></table></figure>

<p>通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了。</p>
<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</p>
<p>异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</p>
<p>包含变量的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</p>
<p>上面的例子中，Model就是一个JavaScript对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; name: &apos;Michael&apos; &#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们根据原来的项目创建工程，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为ctx.render(view, model)的方式。</p>
<p>工程结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view-koa/</span><br><span class="line">|</span><br><span class="line">+- controllers/ &lt;-- Controller</span><br><span class="line">|</span><br><span class="line">+- views/ &lt;-- html模板文件</span><br><span class="line">|</span><br><span class="line">+- static/ &lt;-- 静态资源文件</span><br><span class="line">|</span><br><span class="line">+- controller.js &lt;-- 扫描注册Controller</span><br><span class="line">|</span><br><span class="line">+- app.js &lt;-- 使用koa的js</span><br><span class="line">|</span><br><span class="line">+- package.json &lt;-- 项目描述文件</span><br><span class="line">|</span><br><span class="line">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure>

<p>先用npm install安装依赖包。</p>
<p>然后，我们准备编写以下两个Controller：</p>
<h4 id="处理首页-GET"><a href="#处理首页-GET" class="headerlink" title="处理首页 GET /"></a>处理首页 GET /</h4><p>我们定义一个async函数处理首页URL/：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.render(&apos;index.html&apos;, &#123;</span><br><span class="line">        title: &apos;Welcome&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到koa并没有在ctx对象上提供render方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用ctx.render(view, model)就完成了页面输出。</p>
<h4 id="处理登录请求-POST-signin"><a href="#处理登录请求-POST-signin" class="headerlink" title="处理登录请求 POST /signin"></a>处理登录请求 POST /signin</h4><p>我们再定义一个async函数处理登录请求/signin：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async (ctx, next) =&gt; &#123;</span><br><span class="line">    var</span><br><span class="line">        email = ctx.request.body.email || &apos;&apos;,</span><br><span class="line">        password = ctx.request.body.password || &apos;&apos;;</span><br><span class="line">    if (email === &apos;admin@example.com&apos; &amp;&amp; password === &apos;123456&apos;) &#123;</span><br><span class="line">        // 登录成功:</span><br><span class="line">        ctx.render(&apos;signin-ok.html&apos;, &#123;</span><br><span class="line">            title: &apos;Sign In OK&apos;,</span><br><span class="line">            name: &apos;Mr Node&apos;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 登录失败:</span><br><span class="line">        ctx.render(&apos;signin-failed.html&apos;, &#123;</span><br><span class="line">            title: &apos;Sign In Failed&apos;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于登录请求是一个POST，我们就用ctx.request.body.<name>拿到POST请求的数据，并给一个默认值。</name></p>
<p>登录成功时我们用signin-ok.html渲染，登录失败时我们用signin-failed.html渲染，所以，我们一共需要以下3个View：</p>
<ul>
<li>base.html</li>
<li>signin-ok.html</li>
<li>signin-failed.html</li>
</ul>
<h4 id="集成Nunjucks"><a href="#集成Nunjucks" class="headerlink" title="集成Nunjucks"></a>集成Nunjucks</h4><p>集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给ctx对象绑定一个render(view, model)的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。</p>
<p>我们创建一个templating.js来实现这个middleware：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const nunjucks = require(&apos;nunjucks&apos;);</span><br><span class="line"></span><br><span class="line">function createEnv(path, opts) &#123;</span><br><span class="line">    var</span><br><span class="line">        autoescape = opts.autoescape === undefined ? true : opts.autoescape,</span><br><span class="line">        noCache = opts.noCache || false,</span><br><span class="line">        watch = opts.watch || false,</span><br><span class="line">        throwOnUndefined = opts.throwOnUndefined || false,</span><br><span class="line">        env = new nunjucks.Environment(</span><br><span class="line">            new nunjucks.FileSystemLoader(path || &apos;views&apos;, &#123;</span><br><span class="line">                noCache: noCache,</span><br><span class="line">                watch: watch,</span><br><span class="line">            &#125;), &#123;</span><br><span class="line">                autoescape: autoescape,</span><br><span class="line">                throwOnUndefined: throwOnUndefined</span><br><span class="line">            &#125;);</span><br><span class="line">    if (opts.filters) &#123;</span><br><span class="line">        for (var f in opts.filters) &#123;</span><br><span class="line">            env.addFilter(f, opts.filters[f]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return env;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function templating(path, opts) &#123;</span><br><span class="line">    // 创建Nunjucks的env对象:</span><br><span class="line">    var env = createEnv(path, opts);</span><br><span class="line">    return async (ctx, next) =&gt; &#123;</span><br><span class="line">        // 给ctx绑定render函数:</span><br><span class="line">        ctx.render = function (view, model) &#123;</span><br><span class="line">            // 把render后的内容赋值给response.body:</span><br><span class="line">            ctx.response.body = env.render(view, Object.assign(&#123;&#125;, ctx.state || &#123;&#125;, model || &#123;&#125;));</span><br><span class="line">            // 设置Content-Type:</span><br><span class="line">            ctx.response.type = &apos;text/html&apos;;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 继续处理请求:</span><br><span class="line">        await next();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = templating;</span><br></pre></td></tr></table></figure>

<p>注意到createEnv()函数和前面使用Nunjucks时编写的函数是一模一样的。我们主要关心tempating()函数，它会返回一个middleware，在这个middleware中，我们只给ctx“安装”了一个render()函数，其他什么事情也没干，就继续调用下一个middleware。</p>
<p>使用的时候，我们在app.js添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isProduction = process.env.NODE_ENV === &apos;production&apos;;</span><br><span class="line"></span><br><span class="line">app.use(templating(&apos;views&apos;, &#123;</span><br><span class="line">    noCache: !isProduction,</span><br><span class="line">    watch: !isProduction</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个常量isProduction，它判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。</p>
<p>Node.js在全局变量process中定义了一个环境变量env.NODE_ENV，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为’development’，而部署到服务器时，环境变量应该设置为’production’。在编写代码的时候，要根据当前环境作不同的判断。</p>
<p>注意：生产环境上必须配置环境变量NODE_ENV = ‘production’，而开发环境不需要配置，实际上NODE_ENV可能是undefined，所以判断的时候，不要用NODE_ENV === ‘development’。</p>
<p>这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。</p>
<h4 id="编写View"><a href="#编写View" class="headerlink" title="编写View"></a>编写View</h4><p>在编写View的时候，非常有必要先编写一个base.html作为骨架，其他模板都继承自base.html，这样，才能大大减少重复工作。</p>
<p>编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了base.html。</p>
<p>base.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;description&quot; content=&quot;learn javascript&quot;&gt;</span><br><span class="line">    &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;header style=&quot;background-color:#6f5499;height: 100px;color: #fff;&quot;&gt;</span><br><span class="line">      header top main</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &#123;% block main %&#125; &#123;% endblock %&#125;</span><br><span class="line">  &lt;footer style=&quot;background-color:#ddd; padding: 20px 0;text-align: center;color: #666;&quot;&gt;</span><br><span class="line">      copy right @2019</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>signin-ok.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125; </span><br><span class="line">&#123;% block main %&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Sign in success!&lt;/h1&gt;</span><br><span class="line">  &lt;div class=&quot;alert alert-danger&quot;&gt; </span><br><span class="line">    &lt;strong&gt;This is post login name: &#123;&#123; title &#125;&#125;&lt;/strong&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;% for f in data %&#125;</span><br><span class="line">      &#123;% if f.age &lt; 10 %&#125;</span><br><span class="line">        &lt;li&gt;postValue: 00000&lt;/li&gt;</span><br><span class="line">      &#123;% elif f.age == 10 %&#125;</span><br><span class="line">        &lt;li&gt;postValue: 10&lt;/li&gt;</span><br><span class="line">      &#123;% else %&#125;</span><br><span class="line">        &lt;li&gt;postValue: &#123;&#123; f.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>一切顺利的话，这个view-koa工程应该可以顺利运行。运行前，我们再检查一下app.js里的middleware的顺序：</p>
<p>第一个middleware是记录URL以及页面执行时间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">    console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`);</span><br><span class="line">    var</span><br><span class="line">        start = new Date().getTime(),</span><br><span class="line">        execTime;</span><br><span class="line">    await next();</span><br><span class="line">    execTime = new Date().getTime() - start;</span><br><span class="line">    ctx.response.set(&apos;X-Response-Time&apos;, `$&#123;execTime&#125;ms`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第二个middleware解析POST请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(bodyParser());</span><br></pre></td></tr></table></figure>

<p>第三个middleware负责给ctx加上render()来使用Nunjucks：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(templating(&apos;view&apos;, &#123;</span><br><span class="line">    noCache: !isProduction,</span><br><span class="line">    watch: !isProduction</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>最后一个middleware处理URL路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(controller());</span><br></pre></td></tr></table></figure>

<p>现在，在VS Code中运行代码，不出意外的话，在浏览器输入localhost:3000/，可以看到效果。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>vue简介及vue-element-amdin框架应用</title>
    <url>/blog/2019/10/22/2019-10-22-vue-element-admin/</url>
    <content><![CDATA[<p>最近接到一个基金cms系统需求，之前我们组内搭建类似项目用react居多，这次因为是新启项目，打算用vue尝试一下，之前也有看过vue文档并搭建过小项目，再者vue本身就上手快，于是再撸一遍api,找一套适合的框架（vue-element-amdin），就可以开始干了。service端接口我们选择自己用mongodb搭建（是同事用mongodb+typescript搭建的，之后我打算把他的分享转过来哈哈哈）。</p>
<h1 id="一、vue简介"><a href="#一、vue简介" class="headerlink" title="一、vue简介"></a>一、vue简介</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<a id="more"></a>
<h5 id="渐进式框架的理解"><a href="#渐进式框架的理解" class="headerlink" title="渐进式框架的理解"></a>渐进式框架的理解</h5><p>提供足够的选择，并且没有很多强制性的要求。<br>渐进也可以理解为一步一步的意思，大概意思就是使用Vue的时候，并不需要把整个框架的所有东西都用上，可以根据实际情况选择你需要的部分。</p>
<h5 id="自底向上逐层应用"><a href="#自底向上逐层应用" class="headerlink" title="自底向上逐层应用"></a>自底向上逐层应用</h5><p>由基层开始做起，把基础的东西写好，再逐层往上添加效果和功能。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello Vue!&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>先看一个简单实例代码结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app-selection-banner&quot;&gt;</span><br><span class="line">    &lt;el-row :gutter=&quot;16&quot;&gt;</span><br><span class="line">      &lt;el-col :span=&quot;6&quot;&gt;</span><br><span class="line">        &lt;banner-preview :list=&quot;list&quot; :show-user-types=&quot;showUserTypes&quot; /&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">      &lt;el-col :span=&quot;18&quot;&gt;</span><br><span class="line">        &lt;banner-table :list=&quot;list&quot; :user-type-options=&quot;userTypeOptions&quot; @updateList=&quot;getList&quot; /&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import BannerPreview from &apos;./components/BannerPreview&apos;</span><br><span class="line">import BannerTable from &apos;./components/BannerTable&apos;</span><br><span class="line">import &#123; bannerList &#125; from &apos;@/api/selection&apos;</span><br><span class="line">import &#123; userTypeInfo &#125; from &apos;@/api/common&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;BannerSelection&apos;,</span><br><span class="line">  components: &#123; BannerPreview, BannerTable &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: null,</span><br><span class="line">      userTypeOptions: [],</span><br><span class="line">      showUserTypes: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getList()</span><br><span class="line">    userTypeInfo(&#123; version: &apos;1.0&apos; &#125;).then(response =&gt; &#123;</span><br><span class="line">      this.userTypeOptions = response.data</span><br><span class="line">      this.showUserTypes = (response.data || []).filter((userType) =&gt; &#123;</span><br><span class="line">        return userType.type !== &apos;0&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getList() &#123;</span><br><span class="line">      bannerList().then(response =&gt; &#123;</span><br><span class="line">        const &#123; items &#125; = response.data || []</span><br><span class="line">        this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class="line">      &#125;).catch(err =&gt; console.log(err))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.app-selection-banner&#123;</span><br><span class="line">  background-color:#eee;</span><br><span class="line">  padding:16px;</span><br><span class="line">  .el-col &#123;</span><br><span class="line">    padding: 0 6px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>组件BannerPreview.vue : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;md-wrap&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;md-title&quot;&gt;预览区&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;md-text&quot;&gt;</span><br><span class="line">      &lt;div v-for=&quot;item in showUserTypes&quot; :key=&quot;item.type&quot; class=&quot;block&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;demonstration&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;el-carousel v-if=&quot;previewList(item.type).length&quot; :autoplay=&quot;false&quot; arrow=&quot;never&quot; trigger=&quot;click&quot; height=&quot;100px&quot;&gt;</span><br><span class="line">          &lt;el-carousel-item v-for=&quot;(child, key) in previewList(item.type)&quot; :key=&quot;key&quot;&gt;</span><br><span class="line">            &lt;a :href=&quot;child.link&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">              &lt;img class=&quot;list-img&quot; :src=&quot;child.imgUrl&quot;&gt;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">          &lt;/el-carousel-item&gt;</span><br><span class="line">        &lt;/el-carousel&gt;</span><br><span class="line">        &lt;div v-else class=&quot;no-data&quot;&gt;暂无数据&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;BannerPreview&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">      type: Array,</span><br><span class="line">      default: null</span><br><span class="line">    &#125;,</span><br><span class="line">    showUserTypes: &#123;</span><br><span class="line">      type: Array,</span><br><span class="line">      default: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    previewList(type) &#123;</span><br><span class="line">      const newArr = this.list || []</span><br><span class="line">      return newArr.length &gt; 0 &amp;&amp; newArr.filter((item) =&gt; &#123;</span><br><span class="line">        const &#123; userType &#125; = item || &apos;&apos;</span><br><span class="line">        return item.status === &apos;2&apos; &amp;&amp; (userType.includes(type) || userType.includes(&apos;0&apos;))</span><br><span class="line">      &#125;).slice(0, 5)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.md-wrap&#123;</span><br><span class="line">  background-color:#fff;</span><br><span class="line">  .md-title&#123;</span><br><span class="line">    line-height: 50px;</span><br><span class="line">    border-bottom:1px #eee solid;</span><br><span class="line">    padding-left: 16px;</span><br><span class="line">  &#125;</span><br><span class="line">  .md-text&#123;</span><br><span class="line">    padding: 16px;</span><br><span class="line">    .no-data&#123;</span><br><span class="line">      font-size: 14px;</span><br><span class="line">      color: #999;</span><br><span class="line">      padding: 10px 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .demonstration&#123;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      padding-bottom: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">    .block&#123;</span><br><span class="line">      margin-bottom: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">    .list-img&#123;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-carousel__item h3 &#123;</span><br><span class="line">    color: #475669;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    opacity: 0.75;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    margin: 0;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-carousel__item:nth-child(2n) &#123;</span><br><span class="line">     background-color: #99a9bf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .el-carousel__item:nth-child(2n+1) &#123;</span><br><span class="line">     background-color: #d3dce6;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>比如 created 钩子可以用来在一个实例被创建之后执行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    // `this` 指向 vm 实例</span><br><span class="line">    console.log(&apos;a is: &apos; + this.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// =&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure>

<p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。生命周期钩子的 this 上下文指向调用它的 Vue 实例。</p>
<p>*<font color="red">注意：</font>不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。*</p>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p>
<p>所以，对于任何复杂逻辑，你都应当使用计算属性。</p>
<p>基础例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Original message: “Hello”<br>Computed reversed message: “olleH”</p>
<h4 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h4><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: function () &#123;</span><br><span class="line">    return Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>
<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p>
<h4 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h4><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;,</span><br><span class="line">    fullName: &apos;Foo Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码是命令式且重复的。将它与计算属性的版本进行比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Foo&apos;,</span><br><span class="line">    lastName: &apos;Bar&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>好得多了，不是吗？</p>
<h4 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h4><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;watch-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=&quot;question&quot;&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var watchExampleVM = new Vue(&#123;</span><br><span class="line">  el: &apos;#watch-example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: &apos;&apos;,</span><br><span class="line">    answer: &apos;I cannot give you an answer until you ask a question!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    // 如果 `question` 发生改变，这个函数就会运行</span><br><span class="line">    question: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">      this.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span><br><span class="line">    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span><br><span class="line">    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span><br><span class="line">    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span><br><span class="line">    // 请参考：https://lodash.com/docs#debounce</span><br><span class="line">    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getAnswer: function () &#123;</span><br><span class="line">      if (this.question.indexOf(&apos;?&apos;) === -1) &#123;</span><br><span class="line">        this.answer = &apos;Questions usually contain a question mark. ;-)&apos;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      this.answer = &apos;Thinking...&apos;</span><br><span class="line">      var vm = this</span><br><span class="line">      axios.get(&apos;https://yesno.wtf/api&apos;)</span><br><span class="line">        .then(function (response) &#123;</span><br><span class="line">          vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(function (error) &#123;</span><br><span class="line">          vm.answer = &apos;Error! Could not reach the API. &apos; + error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h1 id="二、Vue与React两个框架的区别和优势对比"><a href="#二、Vue与React两个框架的区别和优势对比" class="headerlink" title="二、Vue与React两个框架的区别和优势对比"></a>二、Vue与React两个框架的区别和优势对比</h1><p>Vue和React两个JavaScript框架都是当下比较受欢迎的，他们两者之间的区别有哪些，各自的优缺点是什么？</p>
<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>除非你一直不关注前端的发展，不然你肯定听说过由Facebook创建的JavaScript UI框架——React。它支撑着包括Instagram在内的大多数Facebook网站。React与当时流行的jQuery,Backbone.js和Angular 1等框架不同，它的诞生改变了JavaScript的世界。其中最大的变化是React推广了Virtual DOM并创造了新的语法——JSX，JSX允许开发者在JavaScript中书写HTML（译者注：即HTML in JavaScript）。</p>
<p>Vue致力解决的问题与React一致，但却提供了另外一套解决方案。Vue使用模板系统而不是JSX，使其对现有应用的升级更加容易。这是因为模板用的就是普通的HTML，通过Vue来整合现有的系统是比较容易的，不需要整体重构。同时Vue声称它更容易学习，我们最近接触Vue，就能证明所言非虚。关于Vue还需要说的是，Vue主要是由一位开发者进行维护的，而不像React一样由如Facebook这类大公司维护。</p>
<h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><p>React与Vue存在很多相似之处：</p>
<ul>
<li>使用 Virtual DOM</li>
<li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li>
<li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li>
</ul>
<h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><p>啊哈，人们经常说Virtual DOM是什么呢？</p>
<p>Vue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫’Virtual DOM’的东西。所谓的Virtual DOM基本上说就是它名字的意思：虚拟DOM，DOM树的虚拟表现。它的诞生是基于这么一个概念：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。</p>
<p>Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。</p>
<p>例子如下，我们可以看看下面这个列表在HTML中的代码是如何写的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul class=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>而在JavaScript中，我们可以用对象简单地创造一个针对上面例子的映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: &apos;ul&apos;, </span><br><span class="line">    props: &#123;&apos;class&apos;: &apos;list&apos;&#125;, </span><br><span class="line">    children: [</span><br><span class="line">        &#123; type: &apos;li&apos;, props: &#123;&#125;, children: [&apos;item 1&apos;] &#125;,</span><br><span class="line">        &#123; type: &apos;li&apos;, props: &#123;&#125;, children: [&apos;item 2&apos;] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实的Virtual DOM会比上面的例子更复杂，但它本质上是一个嵌套着数组的原生对象。</p>
<p>当新一项被加进去这个JavaScript对象时，一个函数会计算新旧Virtual DOM之间的差异并反应在真实的DOM上。计算差异的算法是高性能框架的秘密所在，React和Vue在实现上有点不同。</p>
<p>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p>
<p>而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</p>
<p>在react开发中，经常会遇到组件重复渲染的问题，父组件一个state的变化，就会导致以该组件的所有子组件都重写render，尽管绝大多数子组件的props没有变化</p>
<p>render什么时候会触发</p>
<p>react的生命周期分为了三个阶段：生成期、存在期、销毁期，这样在create、props、state、unMount状态变化时我们可以清楚的看到reacte触发了哪些生命周期钩子以及什么时候会render。</p>
<p>如何避免这些不必要的render:</p>
<ul>
<li>shouldComponentUpdate()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure>

<p>使用shouldComponentUpdate()以让React知道当前状态或属性的改变是否不影响组件的输出，默认返回ture，返回false时不会重写render，而且该方法并不会在初始化渲染或当使用forceUpdate()时被调用，我们要做的只是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  return nextState.someData !== this.state.someData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，state里的数据这么多，还有对象，还有复杂类型数据，react的理念就是拆分拆分再拆分，这么多子组件，我要每个组件都去自己一个一个对比吗？？不存在的，这么麻烦，要知道我们的终极目标是不劳而获-_-</p>
<ul>
<li>React.PureComponent</li>
</ul>
<p>React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新）</p>
<p>关注点：无论组件是否是 PureComponent，如果定义了 shouldComponentUpdate()，那么会调用它并以它的执行结果来判断是否 update。在组件未定义 shouldComponentUpdate() 的情况下，会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行 shallowEqual 比较，一旦新旧不一致，会触发 update。</p>
<p>小结：如果你的应用中，交互复杂，需要处理大量的UI变化，那么使用Virtual DOM是一个好主意。如果你更新元素并不频繁，那么Virtual DOM并不一定适用，性能很可能还不如直接操控DOM。</p>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>React与Vue都鼓励组件化应用。这本质上说，是建议你将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。关于组件化的例子可以在这篇文章的中间部分被找到:</p>
<p>你可以认为组件就是用户界面中的一小块。如果让我来设计Facebook的UI界面，那么聊天窗口会是一个组件，评论会是另一个组件，不断更新的好友列表也会作为一个组件。</p>
<p>在Vue中，如果你遵守一定的规则，你可以使用单文件组件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;li class=&quot;pasta-dish list-unstyled&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-3&quot;&gt;</span><br><span class="line">            &lt;img :src=&quot;this.item.image&quot; :alt=&quot;this.item.name&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-9 text-left&quot;&gt;</span><br><span class="line">            &lt;h3&gt;&#123;&#123;this.item.name&#125;&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &#123;&#123;this.item.desc&#125;&#125;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">            &lt;button v-on:click=&quot;addToOrderNew&quot; class=&quot;btn btn-primary&quot;&gt;Add to order&lt;/button&gt; &lt;mark&gt;&#123;&#123;this.orders&#125;&#125;&lt;/mark&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &apos;pasta-item&apos;,</span><br><span class="line">    props: [&apos;item&apos;],</span><br><span class="line">    data:  function()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            orders: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addToOrderNew: function(y)&#123;</span><br><span class="line">            this.orders += 1;</span><br><span class="line">            this.$emit(&apos;order&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style src=&quot;./Pasta.css&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>正如上面你看到的例子中，HTML, JavaScript和CSS都写在一个文件之中。你不再需要在.vue组件文件中引入CSS，虽然这也是可以的。</p>
<p>React也是非常相似的，JavaScript与JSX被写入同一个组件文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class PastaItem extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; details, index &#125; = this.props;</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;li className=&quot;pasta-dish list-unstyled&quot;&gt;</span><br><span class="line">                &lt;div className=&quot;row&quot;&gt;</span><br><span class="line">                    &lt;div className=&quot;col-md-3&quot;&gt;</span><br><span class="line">                        &lt;img src=&#123;details.image&#125; alt=&#123;details.name&#125; /&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div className=&quot;col-md-9 text-left&quot;&gt;</span><br><span class="line">                        &lt;h3&gt;&#123;details.name&#125;&lt;/h3&gt;</span><br><span class="line">                        &lt;p&gt;</span><br><span class="line">                            &#123;details.desc&#125;</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                        &lt;button onClick=&#123;() =&gt; this.props.addToOrder(index)&#125; className=&quot;btn btn-primary&quot;&gt;Add to order&lt;/button&gt; &lt;mark&gt;&#123;this.props.orders || 0&#125;&lt;/mark&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default PastaItem;</span><br></pre></td></tr></table></figure>

<p>Props<br>在上面两个例子中，我们可以看到React和Vue都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.keys(this.state.pastadishes).map(key =&gt;</span><br><span class="line">    &lt;PastaItem index=&#123;key&#125; key=&#123;key&#125; details=&#123;this.state.pastadishes[key]&#125; addToOrder=&#123;this.addToOrder&#125; orders=&#123;this.state.orders[key]&#125; /&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的JSX库组中，index, key, details, orders 与 addToOrder都是props，数据会被下传到子组件PastaItem中去。</p>
<p>在React中，这是必须的，它依赖一个“单一数据源”作为它的“状态”。</p>
<p>而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pasta-item v-for=&quot;(item, key) in samplePasta&quot; :item=&quot;item&quot; :key=&quot;key&quot; @order=&quot;handleOrder(key)&quot;&gt;&lt;/pasta-item&gt;</span><br></pre></td></tr></table></figure>

<p>这是模板的实现，但这代码完全能工作，然而在React中展现相同数据会更麻烦一点。</p>
<h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4><p>React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。</p>
<p>由于CRA有很多选项，使用起来会稍微麻烦一点。这个工具会逼迫你使用Webpack和Babel。而vue-cli则有模板列表可选，能按需创造不同模板，使用起来更灵活一点。</p>
<p>事实上说，两个工具都非常好用，都能为你建立一个好环境。而且如果可以不配置Webpack的话，我认为这是天大的好事。</p>
<h4 id="Chrome-开发工具"><a href="#Chrome-开发工具" class="headerlink" title="Chrome 开发工具"></a>Chrome 开发工具</h4><p>React和Vue都有很好的Chrome扩展工具去帮助你找出bug。它们会检查你的应用，让你看到Vue或者React中的变化。你也可以看到应用中的状态，并实时看到更新。</p>
<p>React的开发工具: <a href="https://cdn.deliciousbrains.com/content/uploads/2017/06/15151112/react-devtools.mp4" target="_blank" rel="noopener">https://cdn.deliciousbrains.com/content/uploads/2017/06/15151112/react-devtools.mp4</a></p>
<p>Vue的开发工具: <a href="https://cdn.deliciousbrains.com/content/uploads/2017/06/15151111/vue-devtools.mp4" target="_blank" rel="noopener">https://cdn.deliciousbrains.com/content/uploads/2017/06/15151111/vue-devtools.mp4</a></p>
<h4 id="配套框架"><a href="#配套框架" class="headerlink" title="配套框架"></a>配套框架</h4><p>Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。</p>
<p>而不同之处是在于它们如何关联它们各自的配套框架。Vue的核心团队维护着vue-router和vuex，它们都是作为官方推荐的存在。而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。</p>
<h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><p>Vue与react有很多的相似之处，但他们也有完全不一致的地方。</p>
<p>模板 vs JSX：</p>
<p>在 React 中，一切都是 JavaScript。<br>在 React 中，所有的组件的渲染功能都依靠 JSX。<br>JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">import &#123; </span><br><span class="line">  SearchContainer,</span><br><span class="line">  SearchContent</span><br><span class="line">&#125; from &apos;./styledComponent.js&apos;</span><br><span class="line"></span><br><span class="line">import search from &apos;images/search.png&apos;</span><br><span class="line"></span><br><span class="line">class Search extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;SearchContainer&gt;</span><br><span class="line">        &lt;SearchContent &#123; ...this.props &#125;&gt;</span><br><span class="line">          &lt;img src=&#123;search&#125; alt=&quot;&quot;/&gt;</span><br><span class="line">          &lt;span&gt;想吃什么搜这里，川菜&lt;/span&gt;</span><br><span class="line">        &lt;/SearchContent&gt;</span><br><span class="line">      &lt;/SearchContainer&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Search</span><br></pre></td></tr></table></figure>

<p>vue是把html，css，js组合到一起，用各自的处理方式<br>Vue 设置样式的默认方法是单文件组件里类似 style 的标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;m-movie&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;white-bg topbar-bg&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;city-entry&quot;&gt;</span><br><span class="line">        &lt;router-link tag=&quot;span&quot; to=&quot;/cities&quot; class=&quot;city-name&quot;&gt;北京&lt;/router-link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;div class=&quot;switch-hot&quot;&gt;</span><br><span class="line">        &lt;router-link tag=&quot;div&quot; to=&quot;/home/movies/intheater&quot; active-class=&quot;active&quot; class=&quot;hot-item&quot;&gt;正在热映&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link tag=&quot;div&quot; to=&quot;/home/movies/coming&quot; active-class=&quot;active&quot; class=&quot;hot-item&quot;&gt;即将上映&lt;/router-link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;transition :name=&quot;transitionName&quot;&gt;</span><br><span class="line">      &lt;router-view class=&quot;movies-outlet&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      transitionName: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    $route (to, from) &#123;</span><br><span class="line">      if ( to.meta &gt; from.meta ) &#123;</span><br><span class="line">        this.transitionName = &apos;slide-left&apos;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.transitionName = &apos;slide-right&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">@import &apos;~styles/border.styl&apos;</span><br><span class="line">@import &apos;~styles/variables.styl&apos;</span><br><span class="line"></span><br><span class="line">.slide-right-enter-active,</span><br><span class="line">.slide-right-leave-active,</span><br><span class="line">.slide-left-enter-active,</span><br><span class="line">.slide-left-leave-active &#123;</span><br><span class="line">  transition: all 1s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.slide-right-enter &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: translate3d(-100%, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">.slide-right-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: translate3d(100%, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">.slide-left-enter &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: translate3d(100%, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">.slide-left-leave-to &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: translate3d(-100%, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>总结一下，我们发现</p>
<p>Vue的优势包括：</p>
<ul>
<li>模板和渲染函数的弹性选择</li>
<li>简单的语法及项目创建</li>
<li>更快的渲染速度和更小的体积</li>
</ul>
<p>React的优势包括：</p>
<ul>
<li>更适用于大型应用和更好的可测试性</li>
<li>同时适用于Web端和原生App</li>
<li>更大的生态圈带来的更多支持和工具</li>
</ul>
<p>而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：</p>
<ul>
<li>利用虚拟DOM实现快速渲染</li>
<li>轻量级</li>
<li>响应式和组件化</li>
<li>服务器端渲染</li>
<li>易于集成路由工具，打包工具以及状态管理工具</li>
<li>优秀的支持和社区</li>
</ul>
<h1 id="三、vue-element-amdin介绍"><a href="#三、vue-element-amdin介绍" class="headerlink" title="三、vue-element-amdin介绍"></a>三、vue-element-amdin介绍</h1><p>vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 登录 / 注销</span><br><span class="line"></span><br><span class="line">- 权限验证</span><br><span class="line">  - 页面权限</span><br><span class="line">  - 指令权限</span><br><span class="line">  - 权限配置</span><br><span class="line">  - 二步登录</span><br><span class="line"></span><br><span class="line">- 多环境发布</span><br><span class="line">  - dev sit stage prod</span><br><span class="line"></span><br><span class="line">- 全局功能</span><br><span class="line">  - 国际化多语言</span><br><span class="line">  - 多种动态换肤</span><br><span class="line">  - 动态侧边栏（支持多级路由嵌套）</span><br><span class="line">  - 动态面包屑</span><br><span class="line">  - 快捷导航(标签页)</span><br><span class="line">  - Svg Sprite 图标</span><br><span class="line">  - 本地/后端 mock 数据</span><br><span class="line">  - Screenfull全屏</span><br><span class="line">  - 自适应收缩侧边栏</span><br><span class="line"></span><br><span class="line">- 编辑器</span><br><span class="line">  - 富文本</span><br><span class="line">  - Markdown</span><br><span class="line">  - JSON 等多格式</span><br><span class="line"></span><br><span class="line">- Excel</span><br><span class="line">  - 导出excel</span><br><span class="line">  - 导入excel</span><br><span class="line">  - 前端可视化excel</span><br><span class="line">  - 导出zip</span><br><span class="line"></span><br><span class="line">- 表格</span><br><span class="line">  - 动态表格</span><br><span class="line">  - 拖拽表格</span><br><span class="line">  - 内联编辑</span><br><span class="line"></span><br><span class="line">- 错误页面</span><br><span class="line">  - 401</span><br><span class="line">  - 404</span><br><span class="line"></span><br><span class="line">- 組件</span><br><span class="line">  - 头像上传</span><br><span class="line">  - 返回顶部</span><br><span class="line">  - 拖拽Dialog</span><br><span class="line">  - 拖拽Select</span><br><span class="line">  - 拖拽看板</span><br><span class="line">  - 列表拖拽</span><br><span class="line">  - SplitPane</span><br><span class="line">  - Dropzone</span><br><span class="line">  - Sticky</span><br><span class="line">  - CountTo</span><br><span class="line"></span><br><span class="line">- 综合实例</span><br><span class="line">- 错误日志</span><br><span class="line">- Dashboard</span><br><span class="line">- 引导页</span><br><span class="line">- ECharts 图表</span><br><span class="line">- Clipboard(剪贴复制)</span><br><span class="line">- Markdown2html</span><br></pre></td></tr></table></figure>

<p>本项目不支持低版本浏览器(如 ie)，有需求请自行添加 polyfill <a href="https://github.com/PanJiaChen/vue-element-admin/wiki#babel-polyfill" target="_blank" rel="noopener">详情</a></p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── build                      # 构建相关</span><br><span class="line">├── mock                       # 项目mock 模拟数据</span><br><span class="line">├── plop-templates             # 基本模板</span><br><span class="line">├── public                     # 静态资源</span><br><span class="line">│   │── favicon.ico            # favicon图标</span><br><span class="line">│   └── index.html             # html模板</span><br><span class="line">├── src                        # 源代码</span><br><span class="line">│   ├── api                    # 所有请求</span><br><span class="line">│   ├── assets                 # 主题 字体等静态资源</span><br><span class="line">│   ├── components             # 全局公用组件</span><br><span class="line">│   ├── directive              # 全局指令</span><br><span class="line">│   ├── filters                # 全局 filter</span><br><span class="line">│   ├── icons                  # 项目所有 svg icons</span><br><span class="line">│   ├── lang                   # 国际化 language</span><br><span class="line">│   ├── layout                 # 全局 layout</span><br><span class="line">│   ├── router                 # 路由</span><br><span class="line">│   ├── store                  # 全局 store管理</span><br><span class="line">│   ├── styles                 # 全局样式</span><br><span class="line">│   ├── utils                  # 全局公用方法</span><br><span class="line">│   ├── vendor                 # 公用vendor</span><br><span class="line">│   ├── views                  # views 所有页面</span><br><span class="line">│   ├── App.vue                # 入口页面</span><br><span class="line">│   ├── main.js                # 入口文件 加载组件 初始化等</span><br><span class="line">│   └── permission.js          # 权限管理</span><br><span class="line">├── tests                      # 测试</span><br><span class="line">├── .env.xxx                   # 环境变量配置</span><br><span class="line">├── .eslintrc.js               # eslint 配置项</span><br><span class="line">├── .babelrc                   # babel-loader 配置</span><br><span class="line">├── .travis.yml                # 自动化CI配置</span><br><span class="line">├── vue.config.js              # vue-cli 配置</span><br><span class="line">├── postcss.config.js          # postcss 配置</span><br><span class="line">└── package.json               # package.json</span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 克隆项目</span><br><span class="line">git clone https://github.com/PanJiaChen/vue-element-admin.git</span><br><span class="line"></span><br><span class="line"># 进入项目目录</span><br><span class="line">cd vue-element-admin</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"># 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题</span><br><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"># 本地开发 启动项目</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p><a href="https://panjiachen.github.io/vue-element-admin/" target="_blank" rel="noopener">预览地址</a></p>
<h1 id="四、fund-cms前端项目实例"><a href="#四、fund-cms前端项目实例" class="headerlink" title="四、fund-cms前端项目实例"></a>四、fund-cms前端项目实例</h1><p>基金cms管理系统是基于vue-element-amdin框架并通过upm单点登录方式实现的后台管理系统。数据库用的是mongodb实现并输出api接口。</p>
<h4 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h4><p>进入页面判断cookie是否存在，不存在则跳到upm系统进行登录，登录成功自动跳回并带cookie参数。然后取到cookie值并手动种上，此时可以访问api接口。访问接口时如果cookie过期返回错误标识，前端判断自动调到upm登录系统重新登录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取upm单点登录 cookie</span><br><span class="line">const &#123; ticket &#125; = param2Obj(window.location.search) || &apos;&apos;</span><br><span class="line">if (ticket) &#123;</span><br><span class="line">  setToken(ticket)</span><br><span class="line">  const newUrl = location.href.replace(location.search, &apos;&apos;)</span><br><span class="line">  window.location.href = newUrl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断单点登录 cookie</span><br><span class="line">if (!getToken()) &#123;</span><br><span class="line">  logoutRedirect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 退出并跳转</span><br><span class="line"> */</span><br><span class="line">export function logoutRedirect() &#123;</span><br><span class="line">  const toUrl = process.env.VUE_APP_BASE_TOLOGIN + &apos;/auth?appkey=fund-cms&amp;return=&apos; + window.location.href</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;development&apos;) &#123;</span><br><span class="line">    window.location.href = toUrl</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>静态路由：登录进入系统就可以看到的菜单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * constantRoutes</span><br><span class="line"> * a base page that does not have permission requirements</span><br><span class="line"> * all roles can be accessed</span><br><span class="line"> */</span><br><span class="line">export const constantRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/404&apos;,</span><br><span class="line">    component: () =&gt; import(&apos;@/views/error-page/404&apos;),</span><br><span class="line">    hidden: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;&apos;,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: &apos;dashboard&apos;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &apos;dashboard&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/dashboard/index&apos;),</span><br><span class="line">        name: &apos;Dashboard&apos;,</span><br><span class="line">        meta: &#123; title: &apos;dashboard&apos;, icon: &apos;dashboard&apos;, affix: true &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/selection&apos;,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: &apos;/selection/module&apos;,</span><br><span class="line">    alwaysShow: true, // will always show the root menu</span><br><span class="line">    name: &apos;Selection&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &apos;精选&apos;,</span><br><span class="line">      icon: &apos;shopping&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &apos;module&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/selection/module&apos;),</span><br><span class="line">        name: &apos;ModuleSelection&apos;,</span><br><span class="line">        hidden: true,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &apos;模块管理&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        path: &apos;search&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/selection/search&apos;),</span><br><span class="line">        name: &apos;SearchSelection&apos;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &apos;搜索&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        path: &apos;fengj&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/selection/fengj&apos;),</span><br><span class="line">        name: &apos;FengjSelection&apos;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &apos;凤金精选&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>动态路由：需要用户权限匹配才能显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const asyncRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/permission&apos;,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: &apos;/permission/page&apos;,</span><br><span class="line">    alwaysShow: true, // will always show the root menu</span><br><span class="line">    name: &apos;Permission&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &apos;permission&apos;,</span><br><span class="line">      icon: &apos;lock&apos;,</span><br><span class="line">      roles: [&apos;admin&apos;, &apos;editor&apos;] // you can set roles in root nav</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &apos;page&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/permission/page&apos;),</span><br><span class="line">        name: &apos;PagePermission&apos;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &apos;pagePermission&apos;,</span><br><span class="line">          roles: [&apos;admin&apos;] // or you can only set roles in sub nav</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &apos;directive&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/permission/directive&apos;),</span><br><span class="line">        name: &apos;DirectivePermission&apos;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &apos;directivePermission&apos;</span><br><span class="line">          // if do not set roles, means: this page does not require permission</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: &apos;role&apos;,</span><br><span class="line">        component: () =&gt; import(&apos;@/views/permission/role&apos;),</span><br><span class="line">        name: &apos;RolePermission&apos;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: &apos;rolePermission&apos;,</span><br><span class="line">          roles: [&apos;admin&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="api"><a href="#api" class="headerlink" title="api"></a>api</h4><p>接口api通过axios封装，支持环境变量配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import &#123; Message &#125; from &apos;element-ui&apos;</span><br><span class="line">// import store from &apos;@/store&apos;</span><br><span class="line">import &#123; removeToken &#125; from &apos;@/utils/auth&apos;</span><br><span class="line">import &#123; logoutRedirect &#125; from &apos;@/utils&apos;</span><br><span class="line">// create an axios instance</span><br><span class="line">const service = axios.create(&#123;</span><br><span class="line">  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url</span><br><span class="line">  // withCredentials: true, // send cookies when cross-domain requests</span><br><span class="line">  timeout: 5000 // request timeout</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>配置：selection.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import request from &apos;@/utils/request&apos;</span><br><span class="line">//get api</span><br><span class="line">export function fengjList(params) &#123;</span><br><span class="line">  return request(&#123;</span><br><span class="line">    url: &apos;/fengj-management/fengjlist&apos;,</span><br><span class="line">    method: &apos;get&apos;,</span><br><span class="line">    params</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//post api</span><br><span class="line">export function updateOpenStatus(data) &#123;</span><br><span class="line">  return request(&#123;</span><br><span class="line">    url: &apos;/module-management/openmodule/update&apos;,</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：fengj.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; fengjList &#125; from &apos;@/api/selection&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;FengjSelection&apos;,</span><br><span class="line">  components: &#123; FengjPreview, FengjTable &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: null,</span><br><span class="line">      userTypeOptions: [],</span><br><span class="line">      showUserTypes: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getList() &#123;</span><br><span class="line">      fengjList().then(response =&gt; &#123;</span><br><span class="line">        const &#123; items &#125; = response.data || []</span><br><span class="line">        this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开发遇到问题"><a href="#开发遇到问题" class="headerlink" title="开发遇到问题"></a>开发遇到问题</h4><p>1.状态排序<br>数据库里没有status字段，前端拿到数据后再重新排一下序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  getList() &#123;</span><br><span class="line">    fengjList().then(response =&gt; &#123;</span><br><span class="line">      const &#123; items &#125; = response.data || []</span><br><span class="line">      this.list = items.sort((a, b) =&gt; b.status - a.status)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.表单添加动态校验<br>基金产品输入基金code读api异步获取联动。<br>缺点是调两次api。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; searchFundInfo &#125; from &apos;@/api/common&apos;</span><br><span class="line">data() &#123;</span><br><span class="line">  const checkCode = async(rule, value, callback) =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      await searchFundInfo(&#123; key: value &#125;)</span><br><span class="line">      callback()</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      return callback(new Error(err.message))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">      code: [&#123; required: true, message: &apos;基金代码不能为空&apos;, trigger: &apos;blur&apos; &#125;, &#123; validator: checkCode, trigger: &apos;blur&apos; &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.列表组件格式化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;用户类型&quot; prop=&quot;userType&quot; align=&quot;center&quot; :formatter=&quot;formatter&quot; /&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  formatter(row, column) &#123;</span><br><span class="line">    const &#123; userType &#125; = row</span><br><span class="line">    const nameArr = []</span><br><span class="line">    this.userTypeOptions.forEach((item) =&gt; &#123;</span><br><span class="line">      if (userType.includes(item.type)) &#123;</span><br><span class="line">        nameArr.push(item.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nameArr.join()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.子组件调用父组件方法<br>表单更新后，预览区实现自动更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$emit(&apos;updateList&apos;)</span><br><span class="line">//父组件</span><br><span class="line">&lt;fengj-table :list=&quot;list&quot; :user-type-options=&quot;userTypeOptions&quot; @updateList=&quot;getList&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>5.阻止冒泡方法@click.stop<br>咨询列表点击显示预览区和字典联动，操作按钮需要做阻止冒泡处理。（阻止默认行为：@click.prevent）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-button type=&quot;success&quot; size=&quot;mini&quot; @click.stop=&quot;handleUpdate(row)&quot;&gt;</span><br><span class="line">  编辑</span><br><span class="line">&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>

<p>6.文本编辑器缓存问题<br>列表点编辑时候，文本编辑器缓存清不掉，显示上一次的内容,因为用的第三方插件。<br>解决办法添加更新方法，传时间戳，组件内监听更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Tinymce ref=&quot;editor&quot; v-model=&quot;temp.content&quot; :update-con=&quot;updateCon&quot; :height=&quot;200&quot; /&gt;</span><br><span class="line">//点编辑弹层显示时候</span><br><span class="line">handleUpdate(row) &#123;</span><br><span class="line">  this.temp = Object.assign(&#123;&#125;, row) // copy obj</span><br><span class="line">  this.temp.startTime = new Date(this.temp.startTime)</span><br><span class="line">  this.dialogStatus = &apos;update&apos;</span><br><span class="line">  this.dialogFormVisible = true</span><br><span class="line">  this.$nextTick(() =&gt; &#123;</span><br><span class="line">    this.$refs[&apos;dataForm&apos;].clearValidate()</span><br><span class="line">    this.updateCon = new Date().getTime()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tinymce.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    value(val) &#123;</span><br><span class="line">      if (!this.hasChange &amp;&amp; this.hasInit) &#123;</span><br><span class="line">        this.$nextTick(() =&gt;</span><br><span class="line">          window.tinymce.get(this.tinymceId).setContent(this.val || &apos;&apos;))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    language() &#123;</span><br><span class="line">      this.destroyTinymce()</span><br><span class="line">      this.$nextTick(() =&gt; this.initTinymce())</span><br><span class="line">    &#125;,</span><br><span class="line">    updateCon(val) &#123;</span><br><span class="line">      this.$nextTick(() =&gt;</span><br><span class="line">        window.tinymce &amp;&amp; window.tinymce.get(this.tinymceId).setContent(this.newVal || &apos;&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.文本编辑器扩展上传图片功能<br>Tinymce.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;&#123;fullscreen:fullscreen&#125;&quot; class=&quot;tinymce-container&quot; :style=&quot;&#123;width:containerWidth&#125;&quot;&gt;</span><br><span class="line">    &lt;textarea :id=&quot;tinymceId&quot; class=&quot;tinymce-textarea&quot; /&gt;</span><br><span class="line">    &lt;div class=&quot;editor-custom-btn-container&quot;&gt;</span><br><span class="line">      &lt;editorImage color=&quot;#1890ff&quot; class=&quot;editor-upload-btn&quot; @successCBK=&quot;imageSuccessCBK&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//上传成功图片插入文本编辑器中</span><br><span class="line">imageSuccessCBK(arr) &#123;</span><br><span class="line">  const _this = this</span><br><span class="line">  arr.forEach(v =&gt; &#123;</span><br><span class="line">    window.tinymce.get(_this.tinymceId).insertContent(`&lt;img class=&quot;wscnph&quot; src=&quot;$&#123;v.url&#125;&quot; &gt;`)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑上传图片组件：EditorImage.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">  :multiple=&quot;true&quot;</span><br><span class="line">  :file-list=&quot;fileList&quot;</span><br><span class="line">  :show-file-list=&quot;true&quot;</span><br><span class="line">  :on-remove=&quot;handleRemove&quot;</span><br><span class="line">  :on-success=&quot;handleSuccess&quot;</span><br><span class="line">  :before-upload=&quot;beforeUpload&quot;</span><br><span class="line">  class=&quot;editor-slide-upload&quot;</span><br><span class="line">  :action=&quot;uploadUrl&quot;</span><br><span class="line">  list-type=&quot;picture-card&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;</span><br><span class="line">    点击上传</span><br><span class="line">  &lt;/el-button&gt;</span><br><span class="line">&lt;/el-upload&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  uploadUrl() &#123;</span><br><span class="line">    const url = process.env.VUE_APP_BASE_API + &apos;/upload/uploadfile&apos;</span><br><span class="line">    return url</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发总结：vue-element-admin框架搭建后台管理系统还是比较不错，架构清晰，功能全面，上手快。结合mongodb就可以前端一站式完成项目开发。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket介绍及应用</title>
    <url>/blog/2019/11/27/2019-11-27-websocket/</url>
    <content><![CDATA[<h1 id="一、websocket介绍"><a href="#一、websocket介绍" class="headerlink" title="一、websocket介绍"></a>一、websocket介绍</h1><p>最近研究了一下websocket，网上看了一堆文档实例，边学整理了一下文档和实例，作为分享。</p>
<h4 id="WebSocket协议出现的背景"><a href="#WebSocket协议出现的背景" class="headerlink" title="WebSocket协议出现的背景"></a>WebSocket协议出现的背景</h4><p>我们在上网过程中经常用到的是HTTP和HTTPS协议，HTTP协议和HTTPS协议通信过程通常是客户端通过浏览器发出一个请求，服务器接受请求后进行处理并返回结果给客户端，客户端处理结果。</p>
<p>这种机制对于信息变化不是特别频繁的应用可以良好支撑，但对于实时要求高、海量并发的应用来说显得捉襟见肘，尤其在移动互联网蓬勃发展的趋势下，高并发与用户实时响应是Web应用经常面临的问题，比如金融证券的实时信息、社交网络的实时消息推送等。</p>
<a id="more"></a>
<p>WebSocket出现前我们实现推送技术，用的都是轮询，在特定的时间间隔，浏览器自动发出请求，将服务器的消息主动的拉回来，这种情况下，我们需要不断的向服务器发送请求，并且HTTP 请求 的header非常长，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和服务器资源，并且服务器不能主动向客户端推送数据。在这种情况下需要一种高效节能的双向通信机制来保证数据的实时传输，于是基于HTML5规范的WebSocket应运而生。</p>
<h4 id="什么是websocket"><a href="#什么是websocket" class="headerlink" title="什么是websocket"></a>什么是websocket</h4><p>websocket是HTML5的一种新的通信协议，它实现了浏览器与服务器的双向通讯。在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<p>在客户端使用websocket需要创建WebSocket对象，通过提供的open、send、message、close等方法实现创建、发送、监听信息、关闭连接。现在chrome、firefox等浏览器都已经支持了websocket，而IE却没有。</p>
<h4 id="WebSocket与TCP，HTTP的关系"><a href="#WebSocket与TCP，HTTP的关系" class="headerlink" title="WebSocket与TCP，HTTP的关系"></a>WebSocket与TCP，HTTP的关系</h4><p>WebSocket与http协议一样都是基于TCP的，所以他们都是可靠的协议，调用的WebSocket的send函数在实现中最终都是通过TCP的系统接口进行传输的。WebSocket和Http协议一样都属于应用层的协议，WebSocket在建立握手连接时，数据是通过http协议传输的，但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。</p>
<h4 id="WebSocket与HTTP轮询"><a href="#WebSocket与HTTP轮询" class="headerlink" title="WebSocket与HTTP轮询"></a>WebSocket与HTTP轮询</h4><ul>
<li>ajax轮询<br>ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。场景再现：<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有。。（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：你好烦啊，没有啊。。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：好啦好啦，有啦给你。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：。。。。。没。。。。没。。。没有（Response） —- loop</li>
</ul>
<ul>
<li>long poll<br>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。<br>场景再现：<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）<br>服务端：额。。   等待到有消息的时候。。来 给你（Response）<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</li>
</ul>
<p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。简单地说就是，服务器是一个很懒的冰箱（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。</p>
<p>说完这个，我们再来说一说上面的缺陷<br>从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。<br>ajax轮询 需要服务器有很快的处理速度和资源。（速度）<br>long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</p>
<ul>
<li>WebSocket<br>WebSocket的出现解决了轮询实时交互性和全双工的问题。<br>在JavaScript中创建了WebSocket后，会有一个HTTP请求发送到服务器以发起连接。取得服务器响应后，建立的连接使用HTTP升级，从HTTP协议交换为WebSocket协议。即，使用标准的HTTP服务器无法实现WebSocket，只有支持这种协议的专门服务器才能正常工作。<br>WebSocket使用了自定义的协议，未加密的连接不再是http://，而是ws://，默认端口为80，加密的连接也不是https://，而是wss://，默认端口为443。</li>
</ul>
<p>WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p>
<p>WebSocket与HTTP轮询对比得出的结论：<br>WebSocket是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。</p>
<h1 id="二、WebSocket-API"><a href="#二、WebSocket-API" class="headerlink" title="二、WebSocket API"></a>二、WebSocket API</h1><p>上面讲述了WebSocket比HTTP轮询好，下面介绍一下WebSocket API。</p>
<h4 id="创建WebSocket实例"><a href="#创建WebSocket实例" class="headerlink" title="创建WebSocket实例"></a>创建WebSocket实例</h4><p>要创建WebSocket，先实例一个WebSocket对象并传入要连接的URL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var socket = new WebSocket(&apos;http://localhost:8000&apos;);</span><br></pre></td></tr></table></figure>

<p>执行上面语句后，浏览器会马上尝试创建连接，与XHR类似，WebSocket也有一个表示当前状态的readyState属性。不过，这个属性的值与XHR不相同， socket.readyState值如下：</p>
<p>0：正在建立连接， WebSocket.OPENING<br>1：已经建立连接， WebSocket.OPEN<br>2：正在关闭连接， WebSocket.CLOSING<br>3：已经关闭连接， WebSocket.CLOSE<br>WebSocket没有readystatechange事件，不过，有其他事件对应着不同的状态，readyState的值永远从0开始。<br>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class="line"></span><br><span class="line">  //正在建立连接</span><br><span class="line">  console.log(&quot;[readyState]-&quot; + socket.readyState); //0</span><br><span class="line"></span><br><span class="line">  //连接建立成功回调</span><br><span class="line">  socket.onopen = function() &#123;</span><br><span class="line">    console.log(&apos;Connection established.&apos;)</span><br><span class="line">    console.log(&quot;[readyState]-&quot; + socket.readyState); //1</span><br><span class="line">    //发送消息</span><br><span class="line">    // socket.send(&apos;hello world&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  //连接失败回调</span><br><span class="line">  socket.onerror = function() &#123;</span><br><span class="line">    console.log(&quot;[readyState]-&quot; + socket.readyState);//3</span><br><span class="line">    console.log(&apos;Connection error.&apos;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  //连接关闭回调</span><br><span class="line">  socket.onclose = function(event) &#123;</span><br><span class="line">    var code = event.code;</span><br><span class="line">    var reason = event.reason;</span><br><span class="line">    var wasClean = event.wasClean;</span><br><span class="line">    console.log(&quot;[readyState]-&quot; + socket.readyState);//3</span><br><span class="line">    console.log(&apos;Connection closed.&apos;)</span><br><span class="line">    console.log(code, reason, wasClean)</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>要关闭WebSocket连接，可以在任何时候调用close方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket.close();</span><br></pre></td></tr></table></figure>

<p>调用了close()之后，readyState的值立即变为2（正在关闭），关闭连接后就会变成3。</p>
<h4 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h4><p>WebSocket连接建立之后，可以通过连接发送和接收数据。<br>使用send()方法像服务器发送数据，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class="line">socket.send(&apos;hello world&apos;);</span><br></pre></td></tr></table></figure>

<p>当服务器向客户端发来消息时，WebSocket对象会触发message事件。这个message事件与其他传递消息的协议类似，也是把返回的数据保存在event.data属性中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> socket.onmessage = function(event) &#123;</span><br><span class="line">  var data = event.data;</span><br><span class="line">  //处理数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p>WebSocket对象还有其他三个事件，在连接生命周期的不同阶段触发。</p>
<p>open：成功建立连接时触发。<br>error：发生错误时触发，连接断开。<br>close: 连接关闭时触发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var socket = new WebSocket(&apos;ws://localhost:8000&apos;);</span><br><span class="line">socket.onopen = function() &#123;</span><br><span class="line">  console.log(&apos;Connection established.&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">socket.onerror = function() &#123;</span><br><span class="line">  console.log(&apos;Connection error.&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">socket.onclose = function(event) &#123;</span><br><span class="line">  var code = event.code;</span><br><span class="line">  var reason = event.reason;</span><br><span class="line">  var wasClean = event.wasClean;</span><br><span class="line">  console.log(&apos;Connection closed.&apos;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这三个事件中，只有close事件的event对象有额外信息，这个事件的事件对象有三个额外的属性：wasClean、code和reason。<br>其中wasClean是一个布尔值，表示连接是否已经明确的关闭；<br>code是服务器返回的数值状态码；<br>reason是一个字符串，包含服务器发回的信息。</p>
<h1 id="三、WebSocket心跳及重连机制"><a href="#三、WebSocket心跳及重连机制" class="headerlink" title="三、WebSocket心跳及重连机制"></a>三、WebSocket心跳及重连机制</h1><p>在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器端并没有触发onclose的事件。这样会有：服务器会继续向客户端发送多余的链接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的链接状态。因此就有了websocket的心跳了。还有心跳，说明还活着，没有心跳说明已经挂掉了。</p>
<ol>
<li><p>为什么叫心跳包呢？<br>它就像心跳一样每隔固定的时间发一次，来告诉服务器，我还活着。</p>
</li>
<li><p>心跳机制是？<br>心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了。需要重连~</p>
</li>
</ol>
<p>那么需要怎么去实现它呢？如下所有代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;WebSocket Demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);</span><br><span class="line">    /*</span><br><span class="line">    ws.onerror = function(e) &#123;</span><br><span class="line">      console.log(&apos;已关闭&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">    ws.onopen = function(e) &#123;</span><br><span class="line">      console.log(&apos;握手成功&apos;);</span><br><span class="line">      ws.send(&apos;123456789&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    ws.onclose = function() &#123;</span><br><span class="line">      console.log(&apos;已关闭&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    ws.onmessage = function(e) &#123;</span><br><span class="line">      console.log(&apos;收到消息&apos;);</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    var lockReconnect = false;//避免重复连接</span><br><span class="line">    var wsUrl = &quot;wss://echo.websocket.org&quot;;</span><br><span class="line">    var ws;</span><br><span class="line">    var tt;</span><br><span class="line">    function createWebSocket() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        ws = new WebSocket(wsUrl);</span><br><span class="line">        init();</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        console.log(&apos;catch&apos;);</span><br><span class="line">        reconnect(wsUrl);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function init() &#123;</span><br><span class="line">      ws.onclose = function () &#123;</span><br><span class="line">        console.log(&apos;链接关闭&apos;);</span><br><span class="line">        reconnect(wsUrl);</span><br><span class="line">      &#125;;</span><br><span class="line">      ws.onerror = function() &#123;</span><br><span class="line">        console.log(&apos;发生异常了&apos;);</span><br><span class="line">        reconnect(wsUrl);</span><br><span class="line">      &#125;;</span><br><span class="line">      ws.onopen = function () &#123;</span><br><span class="line">        //心跳检测重置</span><br><span class="line">        heartCheck.start();</span><br><span class="line">      &#125;;</span><br><span class="line">      ws.onmessage = function (event) &#123;</span><br><span class="line">        //拿到任何消息都说明当前连接是正常的</span><br><span class="line">        console.log(&apos;接收到消息&apos;);</span><br><span class="line">        heartCheck.start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reconnect(url) &#123;</span><br><span class="line">      if(lockReconnect) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;;</span><br><span class="line">      lockReconnect = true;</span><br><span class="line">      //没连接上会一直重连，设置延迟避免请求过多</span><br><span class="line">      tt &amp;&amp; clearTimeout(tt);</span><br><span class="line">      tt = setTimeout(function () &#123;</span><br><span class="line">        createWebSocket(url);</span><br><span class="line">        lockReconnect = false;</span><br><span class="line">      &#125;, 4000);</span><br><span class="line">    &#125;</span><br><span class="line">    //心跳检测</span><br><span class="line">    var heartCheck = &#123;</span><br><span class="line">      timeout: 3000,</span><br><span class="line">      timeoutObj: null,</span><br><span class="line">      serverTimeoutObj: null,</span><br><span class="line">      start: function()&#123;</span><br><span class="line">        console.log(&apos;start&apos;);</span><br><span class="line">        var self = this;</span><br><span class="line">        this.timeoutObj &amp;&amp; clearTimeout(this.timeoutObj);</span><br><span class="line">        this.serverTimeoutObj &amp;&amp; clearTimeout(this.serverTimeoutObj);</span><br><span class="line">        this.timeoutObj = setTimeout(function()&#123;</span><br><span class="line">          //这里发送一个心跳，后端收到后，返回一个心跳消息，</span><br><span class="line">          console.log(&apos;55555&apos;);</span><br><span class="line">          ws.send(&quot;123456789&quot;);</span><br><span class="line">          self.serverTimeoutObj = setTimeout(function() &#123;</span><br><span class="line">            console.log(111);</span><br><span class="line">            console.log(ws);</span><br><span class="line">            ws.close();</span><br><span class="line">            // createWebSocket();</span><br><span class="line">          &#125;, self.timeout);</span><br><span class="line"></span><br><span class="line">        &#125;, this.timeout)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    createWebSocket(wsUrl);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>具体的思路如下：</p>
<ol>
<li><p>第一步页面初始化，先调用createWebSocket函数，目的是创建一个websocket的方法：new WebSocket(wsUrl);因此封装成函数内如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createWebSocket() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    ws = new WebSocket(wsUrl);</span><br><span class="line">    init();</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.log(&apos;catch&apos;);</span><br><span class="line">    reconnect(wsUrl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步调用init方法，该方法内把一些监听事件封装如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function init() &#123;</span><br><span class="line">  ws.onclose = function () &#123;</span><br><span class="line">    console.log(&apos;链接关闭&apos;);</span><br><span class="line">    reconnect(wsUrl);</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onerror = function() &#123;</span><br><span class="line">    console.log(&apos;发生异常了&apos;);</span><br><span class="line">    reconnect(wsUrl);</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onopen = function () &#123;</span><br><span class="line">    //心跳检测重置</span><br><span class="line">    heartCheck.start();</span><br><span class="line">  &#125;;</span><br><span class="line">  ws.onmessage = function (event) &#123;</span><br><span class="line">    //拿到任何消息都说明当前连接是正常的</span><br><span class="line">    console.log(&apos;接收到消息&apos;);</span><br><span class="line">    heartCheck.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如上第二步，当网络断开的时候，会先调用onerror，onclose事件可以监听到，会调用reconnect方法进行重连操作。正常的情况下，是先调用<br>onopen方法的，当接收到数据时，会被onmessage事件监听到。</p>
</li>
<li><p>重连操作 reconnect代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var lockReconnect = false;//避免重复连接</span><br><span class="line">function reconnect(url) &#123;</span><br><span class="line">  if(lockReconnect) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;;</span><br><span class="line">  lockReconnect = true;</span><br><span class="line">  //没连接上会一直重连，设置延迟避免请求过多</span><br><span class="line">  tt &amp;&amp; clearTimeout(tt);</span><br><span class="line">  tt = setTimeout(function () &#123;</span><br><span class="line">    createWebSocket(url);</span><br><span class="line">    lockReconnect = false;</span><br><span class="line">  &#125;, 4000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如上代码，如果网络断开的话，会执行reconnect方法，使用了一个定时器，4秒后会重新创建一个新的websocket链接，重新调用createWebSocket函数，<br>重新会执行及发送数据给服务器端。</p>
<ol start="5">
<li>最后一步就是实现心跳检测的代码：如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//心跳检测</span><br><span class="line">var heartCheck = &#123;</span><br><span class="line">  timeout: 3000,</span><br><span class="line">  timeoutObj: null,</span><br><span class="line">  serverTimeoutObj: null,</span><br><span class="line">  start: function()&#123;</span><br><span class="line">    console.log(&apos;start&apos;);</span><br><span class="line">    var self = this;</span><br><span class="line">    this.timeoutObj &amp;&amp; clearTimeout(this.timeoutObj);</span><br><span class="line">    this.serverTimeoutObj &amp;&amp; clearTimeout(this.serverTimeoutObj);</span><br><span class="line">    this.timeoutObj = setTimeout(function()&#123;</span><br><span class="line">      //这里发送一个心跳，后端收到后，返回一个心跳消息，</span><br><span class="line">      //onmessage拿到返回的心跳就说明连接正常</span><br><span class="line">      console.log(&apos;55555&apos;);</span><br><span class="line">      ws.send(&quot;123456789&quot;);</span><br><span class="line">      self.serverTimeoutObj = setTimeout(function() &#123;</span><br><span class="line">        console.log(111);</span><br><span class="line">        console.log(ws);</span><br><span class="line">        ws.close();</span><br><span class="line">        // createWebSocket();</span><br><span class="line">      &#125;, self.timeout);</span><br><span class="line"></span><br><span class="line">    &#125;, this.timeout)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>实现心跳检测的思路是：每隔一段固定的时间，向服务器端发送一个ping数据，如果在正常的情况下，服务器会返回一个pong给客户端，如果客户端通过onmessage事件能监听到的话，说明请求正常，这里我们使用了一个定时器，每隔3秒的情况下，如果是网络断开的情况下，在指定的时间内服务器端并没有返回心跳响应消息，因此服务器端断开了，因此这个时候我们使用ws.close关闭连接，在一段时间后(在不同的浏览器下，时间是不一样的，firefox响应更快)，可以通过 onclose事件监听到。因此在onclose事件内，我们可以调用 reconnect事件进行重连操作。</p>
<h1 id="四、WebSocket-实例"><a href="#四、WebSocket-实例" class="headerlink" title="四、WebSocket 实例"></a>四、WebSocket 实例</h1><p>前面已经学习了WebSocket API，包括事件、方法和属性。WebSocket是基于事件驱动，支持全双工通信。下面通过二个简单例子体验一下。</p>
<h4 id="简单在线聊天"><a href="#简单在线聊天" class="headerlink" title="简单在线聊天"></a>简单在线聊天</h4><p>1、通过nodejs在项目里面新建一个server.js，创建服务，指定8181端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var WebSocket = require(&apos;ws&apos;);</span><br><span class="line">var app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class="line">	res.send(&apos;&lt;h1&gt;Welcome Realtime Server&lt;/h1&gt;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">var server = http.createServer(app);</span><br><span class="line">var wss = new WebSocket.Server(&#123;server&#125;);</span><br><span class="line">wss.on(&apos;connection&apos;, function connection(ws) &#123;</span><br><span class="line">    console.log(&apos;链接成功！&apos;);</span><br><span class="line">    ws.on(&apos;message&apos;, function incoming(data) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 把消息发送到所有的客户端</span><br><span class="line">         * wss.clients获取所有链接的客户端</span><br><span class="line">         */</span><br><span class="line">        wss.clients.forEach(function each(client) &#123;</span><br><span class="line">            client.send(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(8181, function listening() &#123;</span><br><span class="line">    console.log(&apos;服务器启动成功！&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在浏览器里输入<a href="http://localhost:8181/测试服务是否启动成功。" target="_blank" rel="noopener">http://localhost:8181/测试服务是否启动成功。</a></p>
<p>2、创建客户端。为了能在多台设备上测试，可以本地在启一个服务来跑客户端代码。<br>通node启一个8282端口的本机服务<br>app.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">var server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class="line">	res.send(&apos;&lt;h1&gt;Welcome client&lt;/h1&gt;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(8282, function listening() &#123;</span><br><span class="line">    console.log(&apos;ok！&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3、创建index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;websocket chat&lt;/h1&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input id=&quot;name&quot; size=&quot;15&quot; type=&quot;text&quot; placeholder=&quot;姓名&quot; value=&quot;&quot;&gt;</span><br><span class="line">        &lt;input id=&quot;message&quot; size=&quot;50&quot; type=&quot;text&quot; placeholder=&quot;内容&quot; value=&quot;&quot;&gt;</span><br><span class="line">        &lt;input id=&quot;btn_post&quot; type=&quot;button&quot; value=&quot;post&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul id=&quot;chat&quot;&gt;&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>可以输入姓名和内容，然后有一个提交按钮来发送数据给服务器。</p>
<p>4、创建websocket链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws = new WebSocket(&quot;ws://localhost:8181&quot;);</span><br></pre></td></tr></table></figure>

<p>要在多台服务测试需要把localhost改成IP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws = new WebSocket(&quot;ws://10.254.124.8:8181&quot;);</span><br></pre></td></tr></table></figure>

<p>5、点击提交按钮或回车向服务器发送信息，使用 ws.send 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">  $(&quot;#btn_post&quot;).click(post);</span><br><span class="line">  $(&quot;#message&quot;).keydown(function(e)&#123;</span><br><span class="line">    if(e.keyCode == 13) post();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">var post = function()&#123;</span><br><span class="line">  var name = $(&quot;#name&quot;).val();</span><br><span class="line">  var mes = $(&quot;#message&quot;).val();</span><br><span class="line">  ws.send(name+&quot; : &quot;+mes);</span><br><span class="line">  $(&quot;input#message&quot;).val(&quot;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>6、服务器接收到信息后返回给客户端，使用 ws.onmessage 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.onmessage = function(e)&#123;</span><br><span class="line">  print(e.data);</span><br><span class="line">&#125;;</span><br><span class="line">var print = function(msg)&#123;</span><br><span class="line">  $(&quot;#chat&quot;).prepend($(&quot;&lt;li&gt;&quot;).text(msg));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>浏览器里输入 <a href="http://10.254.124.8:8282/index.html" target="_blank" rel="noopener">http://10.254.124.8:8282/index.html</a> 可以看到预览效果</p>
<p>实例代码：<a href="https://github.com/hypo1986/websocket-chat" target="_blank" rel="noopener">github</a></p>
<h4 id="模拟股票实例"><a href="#模拟股票实例" class="headerlink" title="模拟股票实例"></a>模拟股票实例</h4><p>上面的例子很简单，只是为了演示如何运用nodejs的ws创建一个WebSocket服务器。且可以接受客户端的消息。那么下面这个例子演示股票的实时更新。客服端只需要连接一次，服务器端会不断地发送新数据，客户端收数据后更新UI.页面如下，有五只股票，开始和停止按钮测试连接和关闭。</p>
<p>服务端：<br>1.模拟五只股票的涨跌。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var stocks = &#123;</span><br><span class="line">    &quot;AAPL&quot;: 95.0,</span><br><span class="line">    &quot;MSFT&quot;: 50.0,</span><br><span class="line">    &quot;AMZN&quot;: 300.0,</span><br><span class="line">    &quot;GOOG&quot;: 550.0,</span><br><span class="line">    &quot;YHOO&quot;: 35.0</span><br><span class="line">&#125;</span><br><span class="line">function randomInterval(min, max) &#123;</span><br><span class="line">    return Math.floor(Math.random() * (max - min + 1) + min);</span><br><span class="line">&#125;</span><br><span class="line">var stockUpdater;</span><br><span class="line">var randomStockUpdater = function() &#123;</span><br><span class="line">    for (var symbol in stocks) &#123;</span><br><span class="line">        if(stocks.hasOwnProperty(symbol)) &#123;</span><br><span class="line">            var randomizedChange = randomInterval(-150, 150);</span><br><span class="line">            var floatChange = randomizedChange / 100;</span><br><span class="line">            stocks[symbol] += floatChange;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var randomMSTime = randomInterval(500, 2500);</span><br><span class="line">    stockUpdater = setTimeout(function() &#123;</span><br><span class="line">        randomStockUpdater();</span><br><span class="line">    &#125;, randomMSTime);</span><br><span class="line">&#125;</span><br><span class="line">randomStockUpdater();</span><br></pre></td></tr></table></figure>

<p>2.连接建立之后就开始更新数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wss.on(&apos;connection&apos;, function (ws) &#123;</span><br><span class="line">  var sendStockUpdates = function (ws) &#123;</span><br><span class="line">      if (ws.readyState == 1) &#123;</span><br><span class="line">          var stocksObj = &#123;&#125;;</span><br><span class="line">          for (var i = 0; i &lt; clientStocks.length; i++) &#123;</span><br><span class="line">            var symbol = clientStocks[i];</span><br><span class="line">              stocksObj[symbol] = stocks[symbol];</span><br><span class="line">          &#125;</span><br><span class="line">          if (stocksObj.length !== 0) &#123;</span><br><span class="line">              ws.send(JSON.stringify(stocksObj));//需要将对象转成字符串。WebSocket只支持文本和二进制数据</span><br><span class="line">              console.log(&quot;更新&quot;, JSON.stringify(stocksObj));</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var clientStockUpdater = setInterval(function () &#123;</span><br><span class="line">      sendStockUpdates(ws);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">  ws.on(&apos;message&apos;, function (message) &#123;</span><br><span class="line">      var stockRequest = JSON.parse(message);//根据请求过来的数据来更新。</span><br><span class="line">      console.log(&quot;收到消息&quot;, stockRequest);</span><br><span class="line">      clientStocks = stockRequest[&apos;stocks&apos;];</span><br><span class="line">      sendStockUpdates(ws);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>客户端：<br>建立连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws = new WebSocket(&quot;ws://localhost:8181&quot;);</span><br></pre></td></tr></table></figure>

<p>onopen直接只有在连接成功后才会触发，在这个时候将客户端需要请求的股票发送给服务端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isClose = false;</span><br><span class="line">  var stocks = &#123;</span><br><span class="line">      &quot;AAPL&quot;: 0, &quot;MSFT&quot;: 0, &quot;AMZN&quot;: 0, &quot;GOOG&quot;: 0, &quot;YHOO&quot;: 0</span><br><span class="line">  &#125;;</span><br><span class="line">  function updataUI() &#123;</span><br><span class="line">      ws.onopen = function (e) &#123;</span><br><span class="line">          console.log(&apos;Connection to server opened&apos;);</span><br><span class="line">          isClose = false;</span><br><span class="line">          ws.send(JSON.stringify(stock_request));</span><br><span class="line">          console.log(&quot;sened a mesg&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //更新UI</span><br><span class="line">      var changeStockEntry = function (symbol, originalValue, newValue) &#123;</span><br><span class="line">          var valElem = $(&apos;#&apos; + symbol + &apos; span&apos;);</span><br><span class="line">          valElem.html(newValue.toFixed(2));</span><br><span class="line">          if (newValue &lt; originalValue) &#123;</span><br><span class="line">              valElem.addClass(&apos;label-danger&apos;);</span><br><span class="line">              valElem.removeClass(&apos;label-success&apos;);</span><br><span class="line">          &#125; else if (newValue &gt; originalValue) &#123;</span><br><span class="line">              valElem.addClass(&apos;label-success&apos;);</span><br><span class="line">              valElem.removeClass(&apos;label-danger&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 处理受到的消息</span><br><span class="line">      ws.onmessage = function (e) &#123;</span><br><span class="line">          var stocksData = JSON.parse(e.data);</span><br><span class="line">          console.log(stocksData);</span><br><span class="line">          for (var symbol in stocksData) &#123;</span><br><span class="line">              if (stocksData.hasOwnProperty(symbol)) &#123;</span><br><span class="line">                  changeStockEntry(symbol, stocks[symbol], stocksData[symbol]);</span><br><span class="line">                  stocks[symbol] = stocksData[symbol];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updataUI();</span><br></pre></td></tr></table></figure>

<p>运行可以看到效果，只需要请求一次，数据就会不断的更新，效果是不是很赞，不用轮询，也不用长连接那么麻烦了。</p>
<h1 id="五、socket-io"><a href="#五、socket-io" class="headerlink" title="五、socket.io"></a>五、socket.io</h1><p>socket.IO是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：<a href="http://socket.io" target="_blank" rel="noopener">http://socket.io</a></p>
<h4 id="客户端使用socket-io"><a href="#客户端使用socket-io" class="headerlink" title="客户端使用socket.io"></a>客户端使用socket.io</h4><p>去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://cdn.socket.io/stable/socket.io.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>下面可以创建使用socket.io库来创建客户端js代码了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var socket = io.connect(&apos;http://localhost&apos;);</span><br><span class="line">socket.on(&apos;news&apos;, function (data) &#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">	socket.emit(&apos;my other event&apos;, &#123; my: &apos;data&apos; &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>socket.on是监听，收到服务器端发来的news的内容，则运行function，其中data就是请求回来的数据，socket.emit是发送消息给服务器端的方法。</p>
<h4 id="使用socket-io和nodejs搭建websocket服务器端"><a href="#使用socket-io和nodejs搭建websocket服务器端" class="headerlink" title="使用socket.io和nodejs搭建websocket服务器端"></a>使用socket.io和nodejs搭建websocket服务器端</h4><p>socket.io不仅可以搭建客户端的websocket服务，而且支持nodejs服务器端的websocket。</p>
<p>nodejs安装socket.io<br>使用node插件管理包，运行下面的命令就可以安装成功socket.io</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install socket.io</span><br></pre></td></tr></table></figure>

<p>没有npm的或者windows用户可以使用github下载socket.io并且放入到node_modules文件夹中。</p>
<h4 id="nodejs建立socket-io服务"><a href="#nodejs建立socket-io服务" class="headerlink" title="nodejs建立socket.io服务"></a>nodejs建立socket.io服务</h4><p>通过nodejs的http模块就可以方便的搭建websocket服务器环境，例如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引入需要的模块：http和socket.io</span><br><span class="line">var http = require(&apos;http&apos;), io = require(&apos;socket.io&apos;);</span><br><span class="line">//创建server</span><br><span class="line">var server = http.createServer(function(req, res)&#123; </span><br><span class="line">  // Send HTML headers and message</span><br><span class="line">  res.writeHead(200,&#123; &apos;Content-Type&apos;: &apos;text/html&apos; &#125;); </span><br><span class="line">  res.end(&apos;&lt;h1&gt;Hello Socket Lover!&lt;/h1&gt;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//端口8000</span><br><span class="line">server.listen(8080);</span><br><span class="line">//创建socket</span><br><span class="line">var socket = io.listen(server);</span><br><span class="line">//添加连接监听</span><br><span class="line">socket.on(&apos;connection&apos;, function(client)&#123;   </span><br><span class="line">	//连接成功则执行下面的监听</span><br><span class="line">	client.on(&apos;message&apos;,function(event)&#123; </span><br><span class="line">		console.log(&apos;Received message from client!&apos;,event);</span><br><span class="line">	&#125;);</span><br><span class="line">	//断开连接callback</span><br><span class="line">	client.on(&apos;disconnect&apos;,function()&#123;</span><br><span class="line">		console.log(&apos;Server has disconnected&apos;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>保存为socket.js然后在命令行执行：node socket.js 即可启动服务器，现在访问localhost:8000就可以了。</p>
<p>目标：Socket.IO旨在让各种浏览器与移动设备上实现实时app功能，模糊化各种传输机制。</p>
<p>缺点：socket.io 在高并发的情况下，稳定性与可靠性其实是不高的。特别是其websocket的实现，websocket本身就存在很多局限，对服务端，客户端的要求都比较高，要使其稳定的运行，还是有蛮多的工作要做的。 另外，socket.io 的作者又开发了另一个类似的实现：<a href="https://github.com/socketio/engine.io" target="_blank" rel="noopener">engine.io</a> 应该是就socket.io的一些不足作了改进。</p>
<h4 id="socket-io搭建多人聊天室实例"><a href="#socket-io搭建多人聊天室实例" class="headerlink" title="socket.io搭建多人聊天室实例"></a>socket.io搭建多人聊天室实例</h4><p>需求分析<br>1、兼容不支持WebSocket的低版本浏览器。<br>2、允许客户端有相同的用户名。<br>3、进入聊天室后可以看到当前在线的用户和在线人数。<br>4、用户上线或退出，所有在线的客户端应该实时更新。<br>5、用户发送消息，所有客户端实时收取。</p>
<p>有了前面的搭建基础，就不多啰嗦了，直接上代码：</p>
<p>index.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt;</span><br><span class="line">        &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;/&gt;</span><br><span class="line">&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt;</span><br><span class="line">        &lt;title&gt;多人聊天室&lt;/title&gt;</span><br><span class="line">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot; /&gt;</span><br><span class="line">        &lt;!--[if lt IE 8]&gt;&lt;script src=&quot;./json3.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;</span><br><span class="line">        &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.dev.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;loginbox&quot;&gt;</span><br><span class="line">            &lt;div style=&quot;width:260px;margin:200px auto;&quot;&gt;</span><br><span class="line">                请先输入你在聊天室的昵称</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; style=&quot;width:180px;&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">				&lt;input type=&quot;button&quot; style=&quot;width:50px;&quot; value=&quot;提交&quot; onclick=&quot;CHAT.usernameSubmit();&quot;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;chatbox&quot; style=&quot;display:none;&quot;&gt;</span><br><span class="line">            &lt;div style=&quot;background:#3d3d3d;height: 28px; width: 100%;font-size:12px;&quot;&gt;</span><br><span class="line">                &lt;div style=&quot;line-height: 28px;color:#fff;&quot;&gt;</span><br><span class="line">                    &lt;span style=&quot;text-align:left;margin-left:10px;&quot;&gt;Websocket多人聊天室&lt;/span&gt;</span><br><span class="line">                    &lt;span style=&quot;float:right; margin-right:10px;&quot;&gt;&lt;span id=&quot;showusername&quot;&gt;&lt;/span&gt; | </span><br><span class="line">					&lt;a href=&quot;javascript:;&quot; onclick=&quot;CHAT.logout()&quot; style=&quot;color:#fff;&quot;&gt;退出&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div id=&quot;doc&quot;&gt;</span><br><span class="line">                &lt;div id=&quot;chat&quot;&gt;</span><br><span class="line">                    &lt;div id=&quot;message&quot; class=&quot;message&quot;&gt;</span><br><span class="line">&lt;div id=&quot;onlinecount&quot; style=&quot;background:#EFEFF4; font-size:12px; margin-top:10px; margin-left:10px; color:#666;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;input-box&quot;&gt;</span><br><span class="line">                        &lt;div class=&quot;input&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; maxlength=&quot;140&quot; placeholder=&quot;请输入聊天内容，按Enter提交&quot; id=&quot;content&quot; name=&quot;content&quot;&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                        &lt;div class=&quot;action&quot;&gt;</span><br><span class="line">                            &lt;button type=&quot;button&quot; id=&quot;mjr_send&quot; onclick=&quot;CHAT.submit();&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                        </span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;./client.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>client.js 客户端代码，里面有详细注释，很清晰。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">	var d = document,</span><br><span class="line">	w = window,</span><br><span class="line">	p = parseInt,</span><br><span class="line">	dd = d.documentElement,</span><br><span class="line">	db = d.body,</span><br><span class="line">	dc = d.compatMode == &apos;CSS1Compat&apos;,</span><br><span class="line">	dx = dc ? dd: db,</span><br><span class="line">	ec = encodeURIComponent;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	w.CHAT = &#123;</span><br><span class="line">		msgObj:d.getElementById(&quot;message&quot;),</span><br><span class="line">		screenheight:w.innerHeight ? w.innerHeight : dx.clientHeight,</span><br><span class="line">		username:null,</span><br><span class="line">		userid:null,</span><br><span class="line">		socket:null,</span><br><span class="line">		//让浏览器滚动条保持在最低部</span><br><span class="line">		scrollToBottom:function()&#123;</span><br><span class="line">			w.scrollTo(0, this.msgObj.clientHeight);</span><br><span class="line">		&#125;,</span><br><span class="line">		//退出，本例只是一个简单的刷新</span><br><span class="line">		logout:function()&#123;</span><br><span class="line">			//this.socket.disconnect();</span><br><span class="line">			location.reload();</span><br><span class="line">		&#125;,</span><br><span class="line">		//提交聊天消息内容</span><br><span class="line">		submit:function()&#123;</span><br><span class="line">			var content = d.getElementById(&quot;content&quot;).value;</span><br><span class="line">			if(content != &apos;&apos;)&#123;</span><br><span class="line">				var obj = &#123;</span><br><span class="line">					userid: this.userid,</span><br><span class="line">					username: this.username,</span><br><span class="line">					content: content</span><br><span class="line">				&#125;;</span><br><span class="line">				this.socket.emit(&apos;message&apos;, obj);</span><br><span class="line">				d.getElementById(&quot;content&quot;).value = &apos;&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;,</span><br><span class="line">		genUid:function()&#123;</span><br><span class="line">			return new Date().getTime()+&quot;&quot;+Math.floor(Math.random()*899+100);</span><br><span class="line">		&#125;,</span><br><span class="line">		//更新系统消息，本例中在用户加入、退出的时候调用</span><br><span class="line">		updateSysMsg:function(o, action)&#123;</span><br><span class="line">			//当前在线用户列表</span><br><span class="line">			var onlineUsers = o.onlineUsers;</span><br><span class="line">			//当前在线人数</span><br><span class="line">			var onlineCount = o.onlineCount;</span><br><span class="line">			//新加入用户的信息</span><br><span class="line">			var user = o.user;</span><br><span class="line">				</span><br><span class="line">			//更新在线人数</span><br><span class="line">			var userhtml = &apos;&apos;;</span><br><span class="line">			var separator = &apos;&apos;;</span><br><span class="line">			for(key in onlineUsers) &#123;</span><br><span class="line">		        if(onlineUsers.hasOwnProperty(key))&#123;</span><br><span class="line">					userhtml += separator+onlineUsers[key];</span><br><span class="line">					separator = &apos;、&apos;;</span><br><span class="line">				&#125;</span><br><span class="line">		    &#125;</span><br><span class="line">			d.getElementById(&quot;onlinecount&quot;).innerHTML = &apos;当前共有 &apos;+onlineCount+&apos; 人在线，在线列表：&apos;+userhtml;</span><br><span class="line">			</span><br><span class="line">			//添加系统消息</span><br><span class="line">			var html = &apos;&apos;;</span><br><span class="line">			html += &apos;&lt;div class=&quot;msg-system&quot;&gt;&apos;;</span><br><span class="line">			html += user.username;</span><br><span class="line">			html += (action == &apos;login&apos;) ? &apos; 加入了聊天室&apos; : &apos; 退出了聊天室&apos;;</span><br><span class="line">			html += &apos;&lt;/div&gt;&apos;;</span><br><span class="line">			var section = d.createElement(&apos;section&apos;);</span><br><span class="line">			section.className = &apos;system J-mjrlinkWrap J-cutMsg&apos;;</span><br><span class="line">			section.innerHTML = html;</span><br><span class="line">			this.msgObj.appendChild(section);	</span><br><span class="line">			this.scrollToBottom();</span><br><span class="line">		&#125;,</span><br><span class="line">		//第一个界面用户提交用户名</span><br><span class="line">		usernameSubmit:function()&#123;</span><br><span class="line">			var username = d.getElementById(&quot;username&quot;).value;</span><br><span class="line">			if(username != &quot;&quot;)&#123;</span><br><span class="line">				d.getElementById(&quot;username&quot;).value = &apos;&apos;;</span><br><span class="line">				d.getElementById(&quot;loginbox&quot;).style.display = &apos;none&apos;;</span><br><span class="line">				d.getElementById(&quot;chatbox&quot;).style.display = &apos;block&apos;;</span><br><span class="line">				this.init(username);</span><br><span class="line">			&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;,</span><br><span class="line">		init:function(username)&#123;</span><br><span class="line">			/*</span><br><span class="line">			客户端根据时间和随机数生成uid,这样使得聊天室用户名称可以重复。</span><br><span class="line">			实际项目中，如果是需要用户登录，那么直接采用用户的uid来做标识就可以</span><br><span class="line">			*/</span><br><span class="line">			this.userid = this.genUid();</span><br><span class="line">			this.username = username;</span><br><span class="line">			</span><br><span class="line">			d.getElementById(&quot;showusername&quot;).innerHTML = this.username;</span><br><span class="line">			//this.msgObj.style.minHeight = (this.screenheight - db.clientHeight + this.msgObj.clientHeight) + &quot;px&quot;;</span><br><span class="line">			this.scrollToBottom();</span><br><span class="line">			</span><br><span class="line">			//连接websocket后端服务器</span><br><span class="line">			this.socket = io.connect(&apos;ws://10.254.124.8:8383&apos;);</span><br><span class="line">			</span><br><span class="line">			//告诉服务器端有用户登录</span><br><span class="line">			this.socket.emit(&apos;login&apos;, &#123;userid:this.userid, username:this.username&#125;);</span><br><span class="line">			</span><br><span class="line">			//监听新用户登录</span><br><span class="line">			this.socket.on(&apos;login&apos;, function(o)&#123;</span><br><span class="line">				CHAT.updateSysMsg(o, &apos;login&apos;);	</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			//监听用户退出</span><br><span class="line">			this.socket.on(&apos;logout&apos;, function(o)&#123;</span><br><span class="line">				CHAT.updateSysMsg(o, &apos;logout&apos;);</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			//监听消息发送</span><br><span class="line">			this.socket.on(&apos;message&apos;, function(obj)&#123;</span><br><span class="line">				var isme = (obj.userid == CHAT.userid) ? true : false;</span><br><span class="line">				var contentDiv = &apos;&lt;div&gt;&apos;+obj.content+&apos;&lt;/div&gt;&apos;;</span><br><span class="line">				var usernameDiv = &apos;&lt;span&gt;&apos;+obj.username+&apos;&lt;/span&gt;&apos;;</span><br><span class="line">				</span><br><span class="line">				var section = d.createElement(&apos;section&apos;);</span><br><span class="line">				if(isme)&#123;</span><br><span class="line">					section.className = &apos;user&apos;;</span><br><span class="line">					section.innerHTML = contentDiv + usernameDiv;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					section.className = &apos;service&apos;;</span><br><span class="line">					section.innerHTML = usernameDiv + contentDiv;</span><br><span class="line">				&#125;</span><br><span class="line">				CHAT.msgObj.appendChild(section);</span><br><span class="line">				CHAT.scrollToBottom();	</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	//通过“回车”提交用户名</span><br><span class="line">	d.getElementById(&quot;username&quot;).onkeydown = function(e) &#123;</span><br><span class="line">		e = e || event;</span><br><span class="line">		if (e.keyCode === 13) &#123;</span><br><span class="line">			CHAT.usernameSubmit();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	//通过“回车”提交信息</span><br><span class="line">	d.getElementById(&quot;content&quot;).onkeydown = function(e) &#123;</span><br><span class="line">		e = e || event;</span><br><span class="line">		if (e.keyCode === 13) &#123;</span><br><span class="line">			CHAT.submit();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>server.js 服务端代码，同样代码里有详细注释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app = require(&apos;express&apos;)();</span><br><span class="line">var http = require(&apos;http&apos;).Server(app);</span><br><span class="line">var io = require(&apos;socket.io&apos;)(http);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class="line">	res.send(&apos;&lt;h1&gt;Welcome Realtime Server&lt;/h1&gt;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//在线用户</span><br><span class="line">var onlineUsers = &#123;&#125;;</span><br><span class="line">//当前在线人数</span><br><span class="line">var onlineCount = 0;</span><br><span class="line"></span><br><span class="line">io.on(&apos;connection&apos;, function(socket)&#123;</span><br><span class="line">	console.log(&apos;a user connected&apos;);</span><br><span class="line">	</span><br><span class="line">	//监听新用户加入</span><br><span class="line">	socket.on(&apos;login&apos;, function(obj)&#123;</span><br><span class="line">		//将新加入用户的唯一标识当作socket的名称，后面退出的时候会用到</span><br><span class="line">		socket.name = obj.userid;</span><br><span class="line">		</span><br><span class="line">		//检查在线列表，如果不在里面就加入</span><br><span class="line">		if(!onlineUsers.hasOwnProperty(obj.userid)) &#123;</span><br><span class="line">			onlineUsers[obj.userid] = obj.username;</span><br><span class="line">			//在线人数+1</span><br><span class="line">			onlineCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//向所有客户端广播用户加入</span><br><span class="line">		io.emit(&apos;login&apos;, &#123;onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj&#125;);</span><br><span class="line">		console.log(obj.username+&apos;加入了聊天室&apos;);</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	//监听用户退出</span><br><span class="line">	socket.on(&apos;disconnect&apos;, function()&#123;</span><br><span class="line">		//将退出的用户从在线列表中删除</span><br><span class="line">		if(onlineUsers.hasOwnProperty(socket.name)) &#123;</span><br><span class="line">			//退出用户的信息</span><br><span class="line">			var obj = &#123;userid:socket.name, username:onlineUsers[socket.name]&#125;;</span><br><span class="line">			</span><br><span class="line">			//删除</span><br><span class="line">			delete onlineUsers[socket.name];</span><br><span class="line">			//在线人数-1</span><br><span class="line">			onlineCount--;</span><br><span class="line">			</span><br><span class="line">			//向所有客户端广播用户退出</span><br><span class="line">			io.emit(&apos;logout&apos;, &#123;onlineUsers:onlineUsers, onlineCount:onlineCount, user:obj&#125;);</span><br><span class="line">			console.log(obj.username+&apos;退出了聊天室&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	//监听用户发布聊天内容</span><br><span class="line">	socket.on(&apos;message&apos;, function(obj)&#123;</span><br><span class="line">		//向所有客户端广播发布的消息</span><br><span class="line">		io.emit(&apos;message&apos;, obj);</span><br><span class="line">		console.log(obj.username+&apos;说：&apos;+obj.content);</span><br><span class="line">	&#125;);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(8383, function()&#123;</span><br><span class="line">	console.log(&apos;listening on *:8383&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>实例代码：<a href="https://github.com/hypo1986/websocket-chat" target="_blank" rel="noopener">github</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>websocket学起来并不难，api也不多，但可扩张和延伸的东西很多，想实现一个完整的项目，需要先有一个完整的设计思路才行。比如是一个在线WebIM系统，实现类似微信，qq的功能，客户端可以看到好友在线状态，在线列表，添加好友，删除好友，新建群组等，消息的发送除了支持基本的文字外，还能支持表情、图片和文件。有兴趣的同学可以继续一起深入研究。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>人生有三重境界</title>
    <url>/blog/2019/06/05/article-001/</url>
    <content><![CDATA[<p>　　人生有三重境界，这三重境界可用一段充满禅机的语言来说明，这段语言便是：看山是山，看水是水；看山不是山，看水不是水；看山还是山，看水还是水。</p>
<p>　　这就是说一个人的人生之初是纯洁无瑕，初识世界，一切都是新鲜的，眼睛看见什么就是什么，人家告诉这是山，他就认识了山，告诉他这是水，他就认识了水。</p>
<a id="more"></a>
<p>　　随着年龄渐长，经历的世事渐多，就发现这个世界的问题了。这个世界的问题越来越多越来越复杂，经常是黑白颠倒，是非混淆，无理走遍天下，有理寸步难行，好人无好报，恶人活千年。进入这个阶段，人是激愤的，不平的，忧虑的，疑问的，警惕的，复杂的。人不愿意再轻易地相信什么。人这个时候看山也感慨，看水也叹息，借古讽今，指桑骂槐。山自然不再是单纯的山，水自然不再是单纯的水。一切的一切都是人的主观意志的载体，所谓好风凭借力，送我上青云。一个人倘停留在人生的这一阶段，那就苦了这条性命了。人就会这山望着那山高，不停攀登，争强好胜，与人比较，怎么做人，如何处世，绞尽脑汁，机关算尽，永无满足的一天。因为这个世界原本就是一个圆的，人外还有人，天外还有天，循环往复，绿水长流。而人的生命是短暂的，有限的，哪里能够去与永恒和无限计较呢？</p>
<p>　　许多人到了人生的第二重境界就到了人生的终点。追求一生，劳碌一生，心高气傲一生，最后发现自己并没达到自己的理想，于是抱恨终生。但是有一些人通过自己的修炼，终于把自己提升到了第三重境界，茅塞顿开，回归自然。人这个时候便会专心致志做自己应该做的事情，不与旁人有任何计较。任你红尘滚滚，我自清风朗月。面对芜杂世俗之事，一笑了之，了了有何不了。这个时候的人看山又是山，看水又是水。正是：人本是人，不必刻意去做人；世本是世，无须精心去处世；便也就是真正的做人与处世了。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title>人生若只如初见，何事秋风悲画扇？等闲变却故人心，却道故人心易变。</title>
    <url>/blog/2019/06/05/article-002/</url>
    <content><![CDATA[<p>所有往事都化为红尘一笑.<br>只留下初见时的惊艳、倾情。忘却也许有过的背叛、伤怀、无奈和悲痛。这是何等美妙的人生境界。<br>时光匆匆，我们已经回不到过去,也许曾经一见倾心,但是再见之时,也许会是伤心之时。若是如此,不如初见时的那份感觉……</p>
<p>“初见惊艳，再见依然”，在我看来，这只是一种美好的愿望。蓦然回首，曾经沧海。只怕早已换了人间。<br>是的，人生若只如初见那该多好，每一个人当最初和你相遇，那种美好的感觉一直就象春天初放的花，那种温馨、那种自然、那种真诚、那种回忆，因此就一直弥漫在了你的生命中。为什么在人的交往中会有误会、费解、猜测和非议呢？只有淡淡的如水的情怀不就足够了吗？就象从未谋面的网友，每次在网上遇到时候互相打个招呼，心中存有彼此的牵挂，不也是一件很美的事情吗？我想君子之交淡如水也就是这个道理吧？美丽的梦和美丽的诗一样，都是可遇而不可求的，常常在最没能料到的时刻里出现。</p>
<a id="more"></a>
<p>我喜欢那样的梦，在梦里，一切都可以重新开始，一切都可以慢慢解释，心里甚至还能感觉到，所有被浪费的时光竟然都能重回时的狂喜与感激。胸怀中满溢着幸福，只因你就在我眼前，对我微笑，一如当年。<br>我真喜欢那样的梦，明明知道你已为我跋涉千里，却又觉得芳草鲜美，落英缤纷，好像你我才初初相遇。<br>由此看来，每个人都有着一种初遇情结，真的就象一杯清水一样清纯透明。</p>
<p>最美的在心不在远处。曾经，初相遇是怎样的一种情怀？人生若只如初见，岂不是人生最好的写照吗？<br>也许生活就是这样的，有人说的对，得到了往往就不会去珍惜。得不到才是一种境界。或者只如初见，那种淡淡的情怀倒是让人释怀、让人坦然、让人心安。一句心灵的问候，足以让你一生难忘，我想人生这个东西，淡然一点往往会是清风明月，太过执着，则就是迷惘了，因此我情愿对于友情、恩怨、功过、得失、钱财……都看的再淡一点，情愿那初见的情节永远留在自己的梦里。</p>
<p>“有的心情你不会明白的，有时候过了五分钟，心情就完全不同了，生命的很多事，你错过一小时，很可能就错过一生了。那时候我只是做了，并不确知些道理，经过这些年，我才明白了，就象今天一样，你住在这个旅馆，正好是我服务的地方，如果你不叫咖啡，或者领班不叫我送，或者我转身时你没有叫我，我们都不能重逢，人生就是这样”。</p>
<p>人生真的就是这个样子吗?我不得而知。<br>人生若只如初见，优伤的美丽只能定格在回忆中。也许哪天转身而去,留下一个美丽的远去背影。完美的弧线，会诉说着对昨日的依恋。也许，在我们认识的人中，有过误会，有过得失，你就会想起初见时的美丽。或者,那天在某个特定的地方,故地重游,突然发现多年未见的你,一下子就回到了初见的情景,初相遇,那是怎样一种让人难以忘怀的感情呢?!初见惊艳，再见依然。但愿再次见到你的时候,你依然那么美丽如初。</p>
<p>秋风微送，把我的心扉吹动，多少尘封的往事都清晰地留在我心中，流淌在我的梦里。<br>人生如此，浮生如斯，情生情死，乃情之至。不是吗？<br>我记得了这样一句话：有情不必终老，暗香浮动恰好，无情未必就是决绝，我只要你记着：初见时彼此的微笑…</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title>狗日的中年——姜文</title>
    <url>/blog/2019/06/05/article-003/</url>
    <content><![CDATA[<p>第一次进入社会工作，我19岁，在一个机械厂做体力活，每天像毛驴一样重复着围磨般的工作，那时候纠结我的最大人生困惑就是吃炒饭省钱还是吃炒面省钱。我的房东是个40岁左右的男人，每天四平八稳的睡到自然醒来，踱着方步把我们几个出租房检查一遍，接着就在大把富足的时间里打盹，喝茶，看天。更要命的，这狗日的居然早点就吃炖肉，香味像狗舌头一样撩涮着我的味觉。那时候，做梦都在盼望着我的40岁什么能到来，我也可以这样踱着方步在时光里浸润，那是一个多么向往年龄啊。</p>
<p>想不到一奔子就挖到中年，才发现中年碎了一地的烟火，中年是个卖笑的年龄，既要讨得老人的欢心，也要做好儿女的榜样，还要时刻关注老婆的脸色，不停迎合上司的心思。中年为了生计，脸面，房子车子票子不停周旋，后来就发现激情对中年人是一种浪费，梦想对于中年是一个牌坊，守得住忠烈，还要做得好婊子。</p>
<a id="more"></a>
<p>中年是一场斗争，人斗不过命，命斗不过时间。多少当时觉得无法过去的坎儿，过上几年突然就风轻云淡了。我没见过一个人把另一个人恨一辈子的，更可怕的是忘记和不在乎，最后都败给了时间，再娇惯的贾宝玉也会遁入空门，再厉害的如来也敌不过妖精的不在乎，万能基督耶稣最后还是让十字架来安抚信徒，再威严的毛泽东还不是躺在那里让人排着队参观。</p>
<p>禅宗讲，一花一世界，一叶一如来。什么年龄做什么事情，不能硬干，60岁的刘晓庆硬是要和30岁的范冰冰比美，不是找死，就是割肉。邓丽君之所以成为传说，就是和他同台的机会都不给你留过，才叫江湖。齐秦、罗大佑生生的把自己沦落成乡间交流会上的马戏团台柱子，得捯饬上一天才能唤醒曾经的故事，和时间死磕，败的只有传奇。与其逆流而上，不如随波逐流，这是对生命的敬畏。</p>
<p>中年是一道清茶。在觥筹之后，人散夜阑之时，一半妥协，一半坚守，两边都让一小步。妥协就成了从容，坚守就成了雅致。从容多了，就会豁达温存的体会一下怨恨之间的不舍以及市井里不精致却扎实亲切的活法。茶要慢品，多一些留白，多一些转身的空间，无声的流泪，抿嘴浅笑，都是一种风景。每段时光都是最好的经过，每个女人都有最美的时光。</p>
<p>中年可以深刻，但千万不要尖刻，看得开，千万别点破。那种咋咋呼呼的人，心中无比自卑才会如此丈八，我见过一种人，全世界没有他能上眼的人和事，语言的巨人，行动的矮子。丈量不见自己的人，他会用尖酸刻薄来过滤生活，终日郁郁寡欢，把日子过的跟太监似的，怎么能体会生活的跌宕起伏，潮涨潮落。一位医生朋友讲了一个笑话，说一日，有患者就诊，患者说，他半生讲究养身养生，没有一点不良爱好，百思不得其解，怎么老是百病缠身？后医生停顿了一会问：你抽烟不？不会。你喝酒不?不会。那你上嫖不？么有。后医生十分沉痛的说了一句：死个哇。看好有甚意义了？医生朋友说，这个世界，医生只能看病，绝对不能救命。这种把生活过的尖刻的人，除了送他奔死的节奏，再不知道如何安慰对待自己这么苛刻的人。</p>
<p>中年是一种满足。下雨有伞，炙热有阴凉，有二两小烧，一碟花生，接受寡妇暗送的秋波，指使光棍挑水，和讨吃子比富，跟一群闲人打五毛钱的麻将，是一种满足。打开微信朋友圈，一看王石邀你去爬山潘石屹请你喝茶，最近有点闲时间登登珠穆朗玛，租豪华游轮领着章子怡、巩俐去夏威夷晒太阳；喝上年份的红酒开始摇杯挂壁，开始收藏12个流失的兽头，有了自己的服装设计等等，也是一种满足。满足是快乐的密码，天天猴急猴急的攀比，除了让你失落失望失魂落魄别无他法。整天还沉浸在谁谁谁怎么就比我混得好？想当初他……这人充其量不是中年，是40岁以上而已。</p>
<p>中年是独处时候的沉默，是热闹时候的不正经，中年不是演讲中的“扬手是春，落手是秋”的轻描淡写，中年是生活场上的“扬手是打的，落手是掏钱”干净利索，在这一扬一落之间，把很多的细节都留给了自己。</p>
<p>中年是狗日的现实。当我们终于可以腰缠万贯时间的时候，才知道中年并不是我看到的表象，狗日的中年不仅消融掉我浓密的长发，也弄丢了我蓬勃的激情和梦想，有些时候，一觉醒来尽然忘记了很多重要的记忆。更要命的是孤独开始富得流油，忧伤也异常亢奋，唯一不变的是毛哥对我的冷若冰霜，也没有几间出租房让我每天检查。现在明白，人生的境界不是天天幸福，而是天天不烦。有一些思念和牵挂可以入梦，梦会绵长，有一些爱好可以入心，生活就会充实，有一两个人懂你的沉默黑夜就不会漫长，有一两个圈子可以分享，时间就会缓慢，没有爱好，时间就会无聊，没有兴趣，生活就会无味。人生不是竞走，用最快的速度到达终点，而忽略了一路的风景和喝彩，这不是中年。</p>
<p>中年不是摇滚，持续的愤怒和亢奋不会快乐，我见过一个斗士，每见一次，斗士都是一副忧国忧民的样子，这个社会仿佛没有一件让他可以称心的事情，鲁迅一般。人生活在极端，总会倾斜，特别是一个女人，忘记柔软等于慢性变态。中年也不是民谣，清新到忘记年龄，单纯到忽略世事，都是要不得的，不能跟生命较劲，弄好了就是刘晓庆，弄不好就成了刘胡兰。中年更不是学院派的民族唱法，千人一面，千人一声。登不上大雅的舞台，又不屑于乡野僻壤的原生态，活得活得就忘记了来路。中年更要懂得敬畏，敬畏生命，敬畏生活，敬畏阅历，敬畏年龄。中年应该有两种事应该尽量少干，一是用自己的嘴干扰别人的人生，二是靠别人的脑子思考自己的人生。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/blog/2019/06/05/article-004/</url>
    <content><![CDATA[<p>当一个人明白了人生不只是爱情的时候，她的心就会变的宽广，变的大度，或者说变的现实！人生就是在这样的聚聚散散中，别人成了你生命中的过客，你成了别人生命中的过客！一定有些什么是我无能为力的，一定有些什么，在落叶之后是我必须放弃的！跳舞吧，如同无人注视一样 ，去爱吧，如同不曾受过伤一样 ，歌唱吧，如同无人聆听一样 ；工作吧，如同不需要钱一样 生活吧，如同今天是末日一样…</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
  </entry>
  <entry>
    <title>async和await处理异步确实好看</title>
    <url>/blog/2019/06/05/async-and-await/</url>
    <content><![CDATA[<p>有了async和await以后，可以跟回调说拜拜了<br>同步方式写异步方法是不是很爽啊</p>
<h3 id="方法例子"><a href="#方法例子" class="headerlink" title="方法例子"></a>方法例子</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">async init(token)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="built_in">let</span> vData = await Api.validate(token)</span><br><span class="line">    vData = JSON.parse(vData.data)</span><br><span class="line">    <span class="keyword">if</span>(vData.success)&#123;</span><br><span class="line">      //todo</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      //todo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch(err) &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>reactecharts-onevents</title>
    <url>/blog/2019/06/05/reactecharts-onevents/</url>
    <content><![CDATA[<p>ReactEchart点击每个节点进入对应详情页面</p>
<h3 id="方法例子"><a href="#方法例子" class="headerlink" title="方法例子"></a>方法例子</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">onclick = &#123;</span><br><span class="line">  click: this.clickEchartsPie.bind(this)</span><br><span class="line">&#125;;</span><br><span class="line">clickEchartsPie(e) &#123;</span><br><span class="line">  //console.log(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;ReactEcharts</span><br><span class="line">  option=&#123;option&#125;</span><br><span class="line">  style=&#123;&#123; height: <span class="string">'300px'</span>, width: <span class="string">'100%'</span> &#125;&#125;</span><br><span class="line">  className=&#123;<span class="string">'react_for_echarts'</span>&#125;</span><br><span class="line">  onEvents=&#123;this.onclick&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ReactEchart</tag>
      </tags>
  </entry>
  <entry>
    <title>post请求参数转义</title>
    <url>/blog/2019/06/05/post-param-transform/</url>
    <content><![CDATA[<p>今天用<a href="https://umijs.org/zh/guide/" target="_blank" rel="noopener">umi</a>脚手架搭建简单项目遇到一个问题，post请求不通<br>问题是参数需要转换</p>
<h3 id="方法例子"><a href="#方法例子" class="headerlink" title="方法例子"></a>方法例子</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> fmtParams (params)&#123;</span><br><span class="line">  <span class="built_in">let</span> fd = new FormData();</span><br><span class="line">  Object.keys(params).forEach(<span class="keyword">function</span>(key)&#123;</span><br><span class="line">    fd.append(key, params[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> loginIn(params) &#123;</span><br><span class="line">  <span class="built_in">return</span> request(Base_url+<span class="string">'/sso/api/v1/login'</span>, &#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    body: fmtParams(params),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>FormData</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo给默认主题landscape添加valine评论功能</title>
    <url>/blog/2019/06/10/hexo-landscape-add-valine/</url>
    <content><![CDATA[<p>近几天用hexo学习搭建了下博客系统，同样遇到了一些坑。。。<br>网上搜到的资料大多数都选择next主题，所以next主题相关的解决方案比较多。我选择的是默认的主题landscape主题，可以自己稍作修改，还是不错的。。。</p>
<p>遇到的第一个坑就是添加评论功能不显示，valine是最好的选择，相关资料太多不多说，直接说注意事项。</p>
<h3 id="配置（写在主题目录下的配置文件里）"><a href="#配置（写在主题目录下的配置文件里）" class="headerlink" title="配置（写在主题目录下的配置文件里）"></a>配置（写在主题目录下的配置文件里）</h3><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  appid: 32131313123</span><br><span class="line">  appkey: 1232131312</span><br><span class="line">  notify: <span class="literal">false</span> <span class="comment"># valine mail notify (true/false) https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  verify: <span class="literal">false</span> <span class="comment"># valine verify code (true/false)</span></span><br><span class="line">  pageSize: 10 <span class="comment"># comment list page size</span></span><br><span class="line">  avatar: mm <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  lang: zh-cn <span class="comment"># i18n: zh-cn/en</span></span><br><span class="line">  placeholder: 请输入 </span><br><span class="line">  guest_info: nick,mail,link <span class="comment">#valine comment header info</span></span><br><span class="line">  visitor: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><font color="red">注意:参数大小写对应很重要appid、appkey，网上复制过来的可能appId、appKey</font></p>
<p>在next主题下默认已经配置好了不用改文章模板，到这步应该已经成功了。但是其他模板还需要手动来添加。</p>
<h3 id="文章模板代码"><a href="#文章模板代码" class="headerlink" title="文章模板代码"></a>文章模板代码</h3><h4 id="目录（-partial-after-footer-ejs）"><a href="#目录（-partial-after-footer-ejs）" class="headerlink" title="目录（/_partial/after-footer.ejs）"></a>目录（/_partial/after-footer.ejs）</h4><p>下面代码插入到文件最后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span>(theme.valine.enable &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">  &lt;script src=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=<span class="string">"//unpkg.com/valine/dist/Valine.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var GUEST_INFO = [<span class="string">'nick'</span>,<span class="string">'mail'</span>,<span class="string">'link'</span>];</span><br><span class="line">    var guest_info = <span class="string">'&lt;%= theme.valine.guest_info %&gt;'</span>.split(<span class="string">','</span>).filter(<span class="keyword">function</span>(item)&#123;</span><br><span class="line">        <span class="built_in">return</span> GUEST_INFO.indexOf(item) &gt; -1</span><br><span class="line">    &#125;);</span><br><span class="line">    var notify = <span class="string">'&lt;%= theme.valine.notify %&gt;'</span> == <span class="literal">true</span>;</span><br><span class="line">    var verify = <span class="string">'&lt;%= theme.valine.verify %&gt;'</span> == <span class="literal">true</span>;</span><br><span class="line">    new Valine(&#123;</span><br><span class="line">      el: <span class="string">'.vcomment'</span>,</span><br><span class="line">      notify: notify,</span><br><span class="line">      verify: verify,</span><br><span class="line">      appId: <span class="string">"&lt;%= theme.valine.appid %&gt;"</span>,</span><br><span class="line">      appKey: <span class="string">"&lt;%= theme.valine.appkey %&gt;"</span>,</span><br><span class="line">      placeholder: <span class="string">"&lt;%= theme.valine.placeholder %&gt;"</span>,</span><br><span class="line">      pageSize: <span class="string">'&lt;%= theme.valine.pageSize %&gt;'</span>,</span><br><span class="line">      avatar: <span class="string">'&lt;%= theme.valine.avatar %&gt;'</span>,</span><br><span class="line">      lang: <span class="string">'&lt;%= theme.valine.lang %&gt;'</span>,</span><br><span class="line">      visitor: <span class="string">'true'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p><font color="red">注意看这里的属性是appId、appKey，而调用的变量要和上面配置时候对应（我就是因为大小写不对应坑了好久，网上复制来的有很多细节问题要注意）</font></p>
<h4 id="目录（-partial-article-ejs）"><a href="#目录（-partial-article-ejs）" class="headerlink" title="目录（/_partial/article.ejs）"></a>目录（/_partial/article.ejs）</h4><p>下面代码插入到文件最后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; theme.valine.enable &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">  &lt;section id=<span class="string">"comments"</span> class=<span class="string">"vcomment"</span>&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p><font color="green">到此landscape主题评论功能OK。</font></p>
<p>appid、appkey怎么获取的，百度一堆大同小异，一般不会遇到问题。<br><a href="https://valine.js.org/" target="_blank" rel="noopener">Leancloud</a><br><a href="https://leancloud.cn/" target="_blank" rel="noopener">Leancloud</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>valine</tag>
      </tags>
  </entry>
  <entry>
    <title>input获取焦点位置</title>
    <url>/blog/2019/06/05/input-focus/</url>
    <content><![CDATA[<p>获取input当前焦点位置插入值</p>
<h2 id="selectionStart"><a href="#selectionStart" class="headerlink" title="selectionStart"></a>selectionStart</h2><h3 id="方法例子"><a href="#方法例子" class="headerlink" title="方法例子"></a>方法例子</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getPosition = element =&gt; &#123;</span><br><span class="line">  <span class="built_in">let</span> cursorPos = 0;</span><br><span class="line">  <span class="keyword">if</span> (document.selection) &#123;</span><br><span class="line">    //IE</span><br><span class="line">    var selectRange = document.selection.createRange();</span><br><span class="line">    selectRange.moveStart(<span class="string">'character'</span>, -element.value.length);</span><br><span class="line">    cursorPos = selectRange.text.length;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.selectionStart || element.selectionStart === <span class="string">'0'</span>) &#123;</span><br><span class="line">    cursorPos = element.selectionStart;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> cursorPos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>selectionStart</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-element-amdin框架npm ERR! Error while executing:解决办法</title>
    <url>/blog/2021/01/11/vue-element-admin-ERR!Errorwhileexecuting/</url>
    <content><![CDATA[<p>最近用vue-element-amdin搭建一套后端管理系统，jenkins打包时候总报一个错误，如下npm ERR! Error while executing:</p>
<p>npm ERR! D:\webWorkerEnvironment\Git\mingw64\bin\git.EXE ls-remote -h -t ssh://git@github.com/sohee-lee7/Squire.git<br>npm ERR!
npm ERR! ssh: Could not resolve hostname github.com: Temporary failure in name resolution<br>npm ERR! fatal: Could not read from remote repository.<br>npm ERR!
npm ERR! Please make sure you have the correct access rights<br>npm ERR! and the repository exists.<br>npm ERR!
npm ERR! exited with error code: 128</p>
<a id="more"></a>
<p>查了好多解决方案，最终查到根本问题是因为一个包导致。<br>发现是由于tui-editor插件里面引用的很多类似eve啊squire啊什么的辅助插件都是用的git链接，整个依赖包只有这个tui-editor是这样子引入的，感觉非常出格。<br>公司内网环境下配置了npm的源可以使用npm安装除了这个插件以外的东西。</p>
<p>这东西基本也不用，所以直接全局查找直接删掉相关及依赖。重新上传打包问题解决。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序环境变量配置方法</title>
    <url>/blog/2021/10/21/weimini-env/</url>
    <content><![CDATA[<p>最近在做微信小程序项目遇到一个问题，怎么区分本地、体验版、生产环境，通过环境变量设置来做区分配置不同环境下不同的API地址，最后用到wx.getAccountInfoSync()方法：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>根目录新建congfig.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 判断环境变量 develop: 开发版，trial：体验版，release：正式版</span><br><span class="line">const envObj = wx.getAccountInfoSync()</span><br><span class="line">const &#123; envVersion, appId &#125; = envObj.miniProgram</span><br><span class="line">const config = &#123;</span><br><span class="line">  develop: &#123;</span><br><span class="line">    wx_tp_webview: &apos;http://192.168.2.115:8080&apos;,</span><br><span class="line">    apiBase: &apos;https://api.test.com&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  trial: &#123;</span><br><span class="line">    wx_tp_webview: &apos;https://test.xxxx.com&apos;,</span><br><span class="line">    apiBase: &apos;https://api.test.com&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  release: &#123;</span><br><span class="line">    wx_tp_webview: &apos;https://www.xxxx.com&apos;,</span><br><span class="line">    apiBase: &apos;https://api.prod.com&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">module.exports = config[envVersion]</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>公共变量调用app.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import config from &apos;./config&apos;</span><br><span class="line">App(&#123;</span><br><span class="line">    onLaunch: function (options) &#123;&#125;,</span><br><span class="line">    wx_tp_webview : config.wx_tp_webview,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>公共接口配置调用api.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import config from &apos;./config&apos;</span><br><span class="line">const ApiBaseUrl = config.apiBase</span><br><span class="line"></span><br><span class="line">wx.request(&#123;</span><br><span class="line">    url: ApiBaseUrl + url,</span><br><span class="line">    method,</span><br><span class="line">    header,</span><br><span class="line">    data,</span><br><span class="line">    dataType: &apos;json&apos;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">        console.log(res,&apos;----res&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function (res) &#123;</span><br><span class="line">        console.log(res,&apos;----res&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>再也不用每次发体验版改一次地址，本地调试改一次，发生产再改一次地址了哈。。。。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>h5手写签名</title>
    <url>/blog/2022/08/11/handsign/</url>
    <content><![CDATA[<p>雄小勤H5项目最近需要实现H5手写签名效果，项目是uniapp框架，uniapp本身没有手写签名组件，经过调研可以用H5属性canvas实现。</p>
<h1 id="一、html部分"><a href="#一、html部分" class="headerlink" title="一、html部分"></a>一、html部分</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;container&quot;&gt;</span><br><span class="line">		&lt;view class=&quot;sign-box&quot;&gt;</span><br><span class="line">			&lt;canvas </span><br><span class="line">				class=&quot;mycanvas&quot; </span><br><span class="line">				canvas-id=&quot;mycanvas&quot; </span><br><span class="line">				@touchstart=&quot;touchstart&quot; </span><br><span class="line">				@touchmove=&quot;touchmove&quot;</span><br><span class="line">				@touchend=&quot;touchend&quot;</span><br><span class="line">			&gt;&lt;/canvas&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">		&lt;view class=&quot;sigh-btns&quot;&gt;</span><br><span class="line">			&lt;u-button text=&quot;重写&quot; @tap=&quot;handleReset&quot;&gt;&lt;/u-button&gt;</span><br><span class="line">			&lt;u-button color=&quot;#2589EF&quot; type=&quot;primary&quot; text=&quot;确认&quot; @tap=&quot;handleConfirm&quot;&gt;&lt;/u-button&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p class="note note-primary">
* touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。<br>
* touchmove事件：当手指在屏幕上滑动的时候连续地触发。 <br>
* touchend事件：当手指从屏幕上离开的时候触发。
</p>

<h1 id="二、js部分"><a href="#二、js部分" class="headerlink" title="二、js部分"></a>二、js部分</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;chooseFilePromise, uploadFilePromise&#125; from &quot;@/util/request/upload.js&quot;</span><br><span class="line">	import &#123;api, urlApi,&#125; from &apos;@/util/request/api.js&apos;</span><br><span class="line">	var tempPoint = []; //用来存放当前画纸上的轨迹点，用来判断当前是否签名了</span><br><span class="line">	export default &#123;</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				ctx: &apos;&apos;, //绘图图像</span><br><span class="line">				points: [], //路径点集合</span><br><span class="line">				uri: &apos;&apos;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;,</span><br><span class="line">		mounted() &#123;</span><br><span class="line">			document.getElementsByTagName(&quot;body&quot;)[0].style.overflowY = &quot;hidden&quot;</span><br><span class="line">			this.ctx = uni.createCanvasContext(&quot;mycanvas&quot;, this); //创建绘图对象</span><br><span class="line">			//设置画笔样式</span><br><span class="line">			this.ctx.lineWidth = 4;</span><br><span class="line">			this.ctx.lineCap = &quot;round&quot;</span><br><span class="line">			this.ctx.lineJoin = &quot;round&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			//触摸开始，获取到起点</span><br><span class="line">			touchstart: function(e) &#123;</span><br><span class="line">				let startX = e.changedTouches[0].x;</span><br><span class="line">				let startY = e.changedTouches[0].y;</span><br><span class="line">				let startPoint = &#123;</span><br><span class="line">					X: startX,</span><br><span class="line">					Y: startY</span><br><span class="line">				&#125;;</span><br><span class="line"> </span><br><span class="line">				/* **************************************************</span><br><span class="line">				    #由于uni对canvas的实现有所不同，这里需要把起点存起来</span><br><span class="line">				 * **************************************************/</span><br><span class="line">				this.points.push(startPoint);</span><br><span class="line">				//每次触摸开始，开启新的路径</span><br><span class="line">				this.ctx.beginPath();</span><br><span class="line">			&#125;,</span><br><span class="line">			//触摸移动，获取到路径点</span><br><span class="line">			touchmove: function(e) &#123;</span><br><span class="line">				let moveX = e.changedTouches[0].x;</span><br><span class="line">				let moveY = e.changedTouches[0].y;</span><br><span class="line">				let movePoint = &#123;</span><br><span class="line">					X: moveX,</span><br><span class="line">					Y: moveY</span><br><span class="line">				&#125;;</span><br><span class="line">				this.points.push(movePoint); //存点</span><br><span class="line">				let len = this.points.length;</span><br><span class="line">				if (len &gt;= 2) &#123;</span><br><span class="line">					this.draw(); //绘制路径</span><br><span class="line">				&#125;</span><br><span class="line">				tempPoint.push(movePoint);</span><br><span class="line">			&#125;,</span><br><span class="line">			// 触摸结束，将未绘制的点清空防止对后续路径产生干扰</span><br><span class="line">			touchend: function() &#123;</span><br><span class="line">				this.points = [];</span><br><span class="line">			&#125;,</span><br><span class="line">			/* ***********************************************</span><br><span class="line">			#   绘制笔迹</span><br><span class="line">			#   1.为保证笔迹实时显示，必须在移动的同时绘制笔迹</span><br><span class="line">			#   2.为保证笔迹连续，每次从路径集合中区两个点作为起点（moveTo）和终点(lineTo)</span><br><span class="line">			#   3.将上一次的终点作为下一次绘制的起点（即清除第一个点）</span><br><span class="line">			************************************************ */</span><br><span class="line">			draw: function() &#123;</span><br><span class="line">				let point1 = this.points[0]</span><br><span class="line">				let point2 = this.points[1]</span><br><span class="line">				this.points.shift()</span><br><span class="line">				this.ctx.moveTo(point1.X, point1.Y)</span><br><span class="line">				this.ctx.lineTo(point2.X, point2.Y)</span><br><span class="line">				this.ctx.stroke()</span><br><span class="line">				this.ctx.draw(true)</span><br><span class="line">				</span><br><span class="line">			&#125;,</span><br><span class="line">			// handleCancel()&#123;</span><br><span class="line">			// 	uni.navigateBack(&#123;</span><br><span class="line">			// 		delta: 1</span><br><span class="line">			// 	&#125;);</span><br><span class="line">			// &#125;,</span><br><span class="line">			//清空画布</span><br><span class="line">			handleReset: function() &#123;</span><br><span class="line">				let that = this</span><br><span class="line">				uni.getSystemInfo(&#123;</span><br><span class="line">					success: function(res) &#123;</span><br><span class="line">						let canvasw = res.windowWidth;</span><br><span class="line">						let canvash = res.windowHeight;</span><br><span class="line">						that.ctx.clearRect(0, 0, canvasw, canvash);</span><br><span class="line">						that.ctx.draw(true);</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;)</span><br><span class="line">				tempPoint = [];</span><br><span class="line">			&#125;,</span><br><span class="line">			//将签名笔迹存到本地</span><br><span class="line">			handleConfirm: function() &#123;</span><br><span class="line">				let that = this</span><br><span class="line">				if (tempPoint.length == 0) &#123;</span><br><span class="line">					uni.showToast(&#123;</span><br><span class="line">						title: &apos;请先签名&apos;,</span><br><span class="line">						icon: &apos;none&apos;,</span><br><span class="line">						duration: 2000</span><br><span class="line">					&#125;);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				uni.canvasToTempFilePath(&#123;</span><br><span class="line">					canvasId: &apos;mycanvas&apos;,</span><br><span class="line">					success: function(res) &#123;</span><br><span class="line">						// const tempPath = res.tempFilePath;</span><br><span class="line">						// console.log(res, &apos;00000&apos;)</span><br><span class="line">						</span><br><span class="line">						const options = &#123;</span><br><span class="line">							tempFilePath: res.tempFilePath,</span><br><span class="line">							tempFile: new Date().getTime() + &apos;.png&apos;,</span><br><span class="line">							url: urlApi + api.commonUpload</span><br><span class="line">						&#125;</span><br><span class="line">						uni.showLoading()</span><br><span class="line">						uploadFilePromise(options).then(ret =&gt; &#123;</span><br><span class="line">							console.log(ret,&apos;88888&apos;)</span><br><span class="line">							that.handleReset()</span><br><span class="line">							that.$emit(&apos;submit&apos;, ret.url)</span><br><span class="line">							</span><br><span class="line">							uni.hideLoading()</span><br><span class="line">							uni.showToast(&#123;</span><br><span class="line">								title: &apos;上传成功&apos;,</span><br><span class="line">								duration: 2000,</span><br><span class="line">								icon: &apos;none&apos;</span><br><span class="line">							&#125;);</span><br><span class="line">						&#125;).catch(e =&gt; &#123;</span><br><span class="line">							uni.hideLoading()</span><br><span class="line">						&#125;)</span><br><span class="line">						// this.uri = tempPath</span><br><span class="line">                        //这里主要是根据实际需求要将笔迹旋转一定角度，再保存下来</span><br><span class="line">						// uni.compressImage(&#123;</span><br><span class="line">						//   src: tempPath,</span><br><span class="line">						//   quality: 100,</span><br><span class="line">						//   rotate:270,</span><br><span class="line">						//   success: function(result) &#123;</span><br><span class="line">						   </span><br><span class="line">						//   &#125;</span><br><span class="line">						// &#125;)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		destroyed() &#123;</span><br><span class="line">			document.getElementsByTagName(&quot;body&quot;)[0].style.overflowY = &quot;&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>lineCap 属性：设置或返回线条末端线帽的样式。(square为正方形)</li>
<li>lineJoin 属性：设置或返回所创建边角的类型，当两条线交汇时。（bevel：斜角、miter尖角）</li>
<li>beginPath() 方法：开始一条路径，或重置当前的路径。</li>
<li>moveTo()：把路径移动到画布中的指定点，不创建线条</li>
<li>lineTo()：添加一个新点，然后在画布中创建从该点到最后指定点的线条</li>
<li>stroke()：绘制已定义的路径</li>
<li>Draw()：用于将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中</li>
<li>clearRect()方法：清空给定矩形内的指定像素。</li>
</ul>
<h1 id="三、css部分"><a href="#三、css部分" class="headerlink" title="三、css部分"></a>三、css部分</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> .container &#123;</span><br><span class="line">	// display: flex;</span><br><span class="line">	// flex-direction: row;</span><br><span class="line">	height: 100%;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">	padding: 32rpx 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sign-box &#123;</span><br><span class="line">	width: 90%;</span><br><span class="line">	height: 70%;</span><br><span class="line">	margin: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sign-view &#123;</span><br><span class="line">	height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sigh-btns &#123;</span><br><span class="line">	// height: 100%;</span><br><span class="line">	margin: auto;</span><br><span class="line">	display: flex;</span><br><span class="line">	// flex-direction: column;</span><br><span class="line">	justify-content: space-around;</span><br><span class="line">	padding: 16rpx;</span><br><span class="line">	margin-top: 20rpx;</span><br><span class="line">	.u-button&#123;</span><br><span class="line">		margin: 0 40rpx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btn &#123;</span><br><span class="line">	margin: auto;</span><br><span class="line">	padding: 8rpx;</span><br><span class="line">	// transform: rotate(90deg);</span><br><span class="line">	border: grey 1rpx solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.mycanvas &#123;</span><br><span class="line">	height: 100%;</span><br><span class="line">	width: 100%;</span><br><span class="line">	background-color: #ECECEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js组件</tag>
        <tag>uniapp</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>分享和前端的感悟</title>
    <url>/blog/2022/08/15/fesharefeeling/</url>
    <content><![CDATA[<h2 id="分享的感悟"><a href="#分享的感悟" class="headerlink" title="分享的感悟"></a>分享的感悟</h2><ul>
<li>分享能推动和加快你的学习力。</li>
<li>分享可以帮助团队快速成长。</li>
<li>增强人际关系，加深组员彼此了解，知道谁更擅长什么。</li>
</ul>
<p>当想要静下来好好学习一项技术时，往往总是会半途而废，因为惰性心理。<br>想一想下次要分享给别人时，会帮你克服这种心理，从而坚持下去。</p>
<p>分享的目的是为了帮助别人进步？<br>实际上分享者往往能够得到更大的进步和回报。</p>
<p>团队里，不要让分享变成压力，而是轻松的。在和同事相互沟通、讨论、帮助和共同进步过程中，获得更多乐趣，积极主动帮助同事解决问题，同事也同样会帮助你。</p>
<a id="more"></a>
<p>不会什么就讲什么，讲什么就会什么，而且越讲越精通。</p>
<h2 id="前端的感悟"><a href="#前端的感悟" class="headerlink" title="前端的感悟"></a>前端的感悟</h2><p>前端其实是个特别苦逼的职业，因为前端技术一直革命的特别快，新技术、新技巧在不断地被发明出来。当你刚把jquery学精通以为可以叱咤风云时，却发现它马上过时了，nodejs、react、vue等快速崛起，全栈、组件化、工程化等概念更让人头疼，怎么办呢，继续学吧，因为人生的全部意义就是无穷尽的探索未知。</p>
<p>关注职业发展，提高团队整体能力。（20%知识 + 80%能力）<br>知识：javascript、vue、react、nodejs、html5…<br>能力：编程能力、架构能力、工程能力、全栈能力、管理能力</p>
<p>技术圈里流行一个笑话，说的是一个人，工作了三年，却只有一年的经验，因为后面两年都在重复第一年的工作。</p>
<p>所以我们要做的事，就是尽量不做长久重复劳动，当你觉得现在的工作，越来越舒适，越来越缺少风险的时候，就应该引起警惕了。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>前端感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发规范整理</title>
    <url>/blog/2022/08/10/frontendspecification/</url>
    <content><![CDATA[<h1 id="一、为什么要有规范"><a href="#一、为什么要有规范" class="headerlink" title="一、为什么要有规范"></a>一、为什么要有规范</h1><ul>
<li>降低新成员融入团队的成本, 同时也一定程度避免挖坑；</li>
<li>提高开发效率、团队协作效率, 降低沟通成本；</li>
<li>实现高度统一的代码风格，方便review, 另外一方面可以提高项目的可维护性；</li>
<li>规范是实现自动化的基础；</li>
<li>规范是一个团队知识沉淀的直接输出；</li>
</ul>
<p>如果开发团队就一个人的话，那么自己写的代码就是规范，随着公司业务的扩展，团队不断壮大，这时候就要开始考虑协作和编码规范问题了。</p>
<a id="more"></a>
<h1 id="二、html规范"><a href="#二、html规范" class="headerlink" title="二、html规范"></a>二、html规范</h1><h3 id="html类型"><a href="#html类型" class="headerlink" title="html类型"></a>html类型</h3><ul>
<li>doctype大写</li>
<li>规定字符编码</li>
<li>IE兼容模式</li>
<li>设备尺寸兼容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="html代码书写规范"><a href="#html代码书写规范" class="headerlink" title="html代码书写规范"></a>html代码书写规范</h3><p>缩进：使用 2 个空格或4个空格（一个 tab），嵌套的节点应该缩进<br>语义化标签：HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div<br>分块注释：在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释<br>引号使用：使用双引号(“ “) 而不是单引号(’ ‘) </p>
<h3 id="标签上属性的顺序"><a href="#标签上属性的顺序" class="headerlink" title="标签上属性的顺序"></a>标签上属性的顺序</h3><ul>
<li>class ( class 是为高可复用组件设计的,所以应处在第一位)</li>
<li>id name (id 更加具体且应该尽量少使用,所以将它放在第二位)</li>
<li>data-*</li>
<li>src for type href value</li>
<li>placeholder title alt</li>
<li>aria-* role</li>
<li>required readonly disabled</li>
</ul>
<h3 id="html书写注意事项"><a href="#html书写注意事项" class="headerlink" title="html书写注意事项"></a>html书写注意事项</h3><ul>
<li>不要省略可选的结束标签</li>
<li>特殊符号的使用HTML字符实体（如：空格 &nbsp; 或 &gt; &reg;）</li>
<li>td/th要在tr里，li要在ul/ol里；ul/ol里只能有li，不能包含其他元素</li>
<li>行内元素不能包含块级元素</li>
<li>注意不要使用重复属性</li>
<li>不要在https的链接里写http的图片，图片（<img src="“//img.xx.com”">）</li>
<li>编写HTML代码时，尽量避免多余的层级嵌套</li>
<li>任何时候都要尽量使用最少的标签并保持最小的复杂度</li>
</ul>
<h1 id="三、css规范"><a href="#三、css规范" class="headerlink" title="三、css规范"></a>三、css规范</h1><h3 id="css命名"><a href="#css命名" class="headerlink" title="css命名"></a>css命名</h3><ul>
<li>类名使用小写字母，以中划线分隔</li>
<li>id 采用驼峰式命名</li>
<li>命名语义化</li>
<li>尽量使用缩写、低代码</li>
</ul>
<h3 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h3><ul>
<li>位置属性 position top right z-index display float</li>
<li>大小 width height padding margin</li>
<li>文字系列 font line-height letter-spacing color text-align</li>
<li>背景background border</li>
<li>其他 animation transition</li>
</ul>
<h3 id="OOCSS规范"><a href="#OOCSS规范" class="headerlink" title="OOCSS规范"></a>OOCSS规范</h3><p>概念：Object Oriented CSS，面向对象的CSS，旨在编写高可复用、低耦合和高扩展的CSS代码。<br>OOCSS是以面向对象的思想去定义样式，将抽象和实现分离，抽离公共代码。<br>最典型的oocss规范使用案例：bootstrap</p>
<h3 id="区分结构与样式"><a href="#区分结构与样式" class="headerlink" title="区分结构与样式"></a>区分结构与样式</h3><p>在定义一个可复用性的组件库时，我们仅创建基础的结构（html）和基础的类名，不应该创建类似于border, width, height, background等样式规则，这样使组件库更灵活和可扩展性。组件库在不同环境下的样式所要求不一样，若未能区分其结构和样式，给其添加样式，会使其变成一个特定的组件库，而难以复用。</p>
<h3 id="css注意事项"><a href="#css注意事项" class="headerlink" title="css注意事项"></a>css注意事项</h3><ul>
<li>所有声明都必须以分好结尾</li>
<li>避免0值指定单位，例如 margin:0; 代替 margin:0px;</li>
<li>选择器中的属性加双引号，例如input[type=“text”]</li>
<li>十六进制值应该全部小写，例如 #ff6600</li>
<li>不要出现空的规则（声明块中没有声明语句）</li>
<li>不要设置太大的z-index(一般在10以内)</li>
<li>用border:0;代替border:none;</li>
<li>对于属性值或颜色值参数，省略小于1的小数前面的0，例如（.5;代替0.5；）</li>
<li>important前插入一个空格</li>
</ul>
<h1 id="四、js规范"><a href="#四、js规范" class="headerlink" title="四、js规范"></a>四、js规范</h1><h3 id="js书写"><a href="#js书写" class="headerlink" title="js书写"></a>js书写</h3><ul>
<li>变量和函数的命名规则</li>
<li>空格、缩进规则统一</li>
<li>注释的使用规则</li>
<li>其他常用规范</li>
</ul>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>命名方法：小驼峰式命名法。<br>命名规范：前缀应当是名词。(函数的名字前缀为动词，以此区分变量和函数)<br>命名建议：尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型。</p>
<h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><p>命名方法：小驼峰式命名法。<br>命名规范：前缀应当是名词。(函数的名字前缀为动词，以此区分变量和函数)<br>命名建议：尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型。</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>命名方法：名称全大写。<br>命名规范：使用大写字母和下划线组合命名。</p>
<h3 id="构造函数命名"><a href="#构造函数命名" class="headerlink" title="构造函数命名"></a>构造函数命名</h3><p>命名方法：大驼峰式命名，首字母大写。<br>命名规范：前缀为命名。</p>
<h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>① 单独一行：//(双斜线)与注释文字之间保留一个空格。<br>② 在代码后面添加注释：//(双斜线)与代码之间保留一个空格，并且//(双斜线)与注释文字之间保留一个空格。<br>③ 注释代码：//(双斜线)与代码之间保留一个空格。</p>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>① 若开始(/<em>)和结束(</em>/)都在一行，推荐采用单行注释。<br>② 若至少三行注释时，第一行为/<em>，最后行为</em>/，其他行以<em>开始，并且注释文字与</em>保留一个空格。</p>
<h3 id="函数-方法-注释"><a href="#函数-方法-注释" class="headerlink" title="函数(方法)注释"></a>函数(方法)注释</h3><p>说明：函数(方法)注释也是多行注释的一种，但是包含了特殊的注释要求。<br>语法：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">* 函数说明</span><br><span class="line">* @关键字</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="js命名规则"><a href="#js命名规则" class="headerlink" title="js命名规则"></a>js命名规则</h3><ul>
<li>变量和函数为小驼峰法标识, 即除第一个单词之外，其他单词首字母大写（ lowerCamelCase）</li>
<li>全局变量为大写 (UPPERCASE )</li>
<li>常量 (如 PI) 为大写 (UPPERCASE )</li>
<li>通常在 JavaScript 中被认为是减法，所以不允许使用。</li>
<li>变量名不要以 $ 作为开始标记，会与很多 JavaScript 库冲突。</li>
</ul>
<h3 id="js注意事项"><a href="#js注意事项" class="headerlink" title="js注意事项"></a>js注意事项</h3><ul>
<li>所有命名最好使用英语表示。</li>
<li>所有变量名应该明确而必要，尽量避免不必要的容易混淆的缩写。</li>
<li>对应的方法应该使用对应的动词，例如：get/set, add/remove, create/destroy, * start/stop, insert/delete, begin/end。</li>
<li>应该避免双重否定意义的变量，例如：bIsNotError, bIsNotFound，不可取。</li>
<li>变量应该在最小的范围内定义，并尽可能的保持最少的活动时间。</li>
<li>循环变量最好在循环中定义。例如for(var i=0,m=10;i++)</li>
<li>尽量避免复杂的条件语句，可以使用临时的boolean变量代替。</li>
<li>一定要避免在条件中执行语句，例如：if((i=3)&gt;2){}，不可取。</li>
</ul>
<h1 id="五、其他规范"><a href="#五、其他规范" class="headerlink" title="五、其他规范"></a>五、其他规范</h1><h3 id="项目及目录"><a href="#项目及目录" class="headerlink" title="项目及目录"></a>项目及目录</h3><ul>
<li>项目命名：大写或小写，中划线分割</li>
<li>目录命名：全部小写或小驼峰式</li>
<li>文件命名：小驼峰式</li>
<li>组件命名：大驼峰式</li>
<li>尽量语义化</li>
</ul>
<h3 id="前端编辑器"><a href="#前端编辑器" class="headerlink" title="前端编辑器"></a>前端编辑器</h3><ul>
<li><p>vscode：无数大佬调侃过，微软这两年干的好事儿有两个，一个是推出了typescript，一个是推出了vscode。可见vscode的受欢迎程度。开源免费、插件多、很多漂亮主题。</p>
</li>
<li><p>WebStorm：WebStorm 是JetBrains公司旗下的前端开发工具。被称为最智能的JavaScriptIDE。具有很强的智能提示、强大的git管理。但需要破解使用。</p>
</li>
<li><p>HBuilderX：DCloud全新推出的一款HTML5的Web开发工具 HBuilderX，H是HTML的首字母，Builder是构造者，X是HBuilder的下一代版本，HBuilderX 是一款编辑器和IDE的完美结合，体积小巧，启动秒开，默认包含优秀的字处理能力，创新众多其他编辑器不具备的高效字处理模型。国产、uniapp。</p>
</li>
<li><p>sublime3：sublime text是一个轻量级的编辑器，也是支持各种编程语言，sublime text所有的强大功能都是支持插件的，而且快捷键十分的好用，可以极大的减少开发的劳动程度，使用sublime就是要使用其快捷键和插件。轻量级、启动快。</p>
</li>
</ul>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>好的代码每行都像一道风景，让人赏心悦目。<br>乱的代码会让人心情烦躁，甚至直接疯掉。<br>所以我们要养成好的编码习惯，<br>即有益于自己，也有益于他人。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端规范</tag>
      </tags>
  </entry>
  <entry>
    <title>webrtc-streamer实现网页直播摄像头rstp</title>
    <url>/blog/2022/12/28/webrtc-streamer/</url>
    <content><![CDATA[<p>刚做完一个web端操作巡检机器人项目，其中机器人主要包含海康摄像头设备，红外和可见光两种，官方3.2web插件比较复杂，而且有一定的兼容性问题，经过调研webrtc-streamer是一个相对比较好的实现方式，经过测试延迟低毫秒级别。</p>
<p>本组件还集成了视频框选截图功能。</p>
<p>于是开始铺坑。首先网上搜集资料，查看<a href="https://github.com/mpromonet/webrtc-streamer/" target="_blank" rel="noopener">官方git</a>。</p>
<h1 id="一、启动webrtc服务"><a href="#一、启动webrtc服务" class="headerlink" title="一、启动webrtc服务"></a>一、启动webrtc服务</h1><p>使用webrtc-streamer组件首先需要启动一个本地rtc服务，window系统比较简单，从这里<a href="https://github.com/mpromonet/webrtc-streamer/releases" target="_blank" rel="noopener">https://github.com/mpromonet/webrtc-streamer/releases</a><br>下载适合项目需求的webrtc-streamer源码包，本文以webrtc-streamer-v0.7.0-Linux-x86_64-Release.tar.gz为例，解压后直接运行webrtc-streamer.exe即可，默认服务8000端口。</p>
<p>使用docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker中获取webrtc-streamer</span><br><span class="line">docker pull mpromonet/webrtc-streamer</span><br><span class="line"># 启动webrtc-streamer镜像</span><br><span class="line">docker run -itd -p 8000:8000 --name webrtc-streamer mpromonet/webrtc-streamer</span><br></pre></td></tr></table></figure>

<p>docker部署可能会遇到各种问题，可以找运维同学帮忙。</p>
<a id="more"></a>

<h1 id="二、网页连接海康视频"><a href="#二、网页连接海康视频" class="headerlink" title="二、网页连接海康视频"></a>二、网页连接海康视频</h1><p>以下是以vue项目为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">		&lt;div class=&quot;w-top&quot;&gt;</span><br><span class="line">			&lt;video </span><br><span class="line">				:id=&quot;videoName&quot;</span><br><span class="line">				:ref=&quot;videoName&quot;</span><br><span class="line">				controls </span><br><span class="line">				autoplay </span><br><span class="line">				autobuffer</span><br><span class="line">				muted </span><br><span class="line">				preload=&apos;auto&apos;</span><br><span class="line">				allowfullscreen=&quot;true&quot;</span><br><span class="line">				:width=&quot;vWidth&quot; </span><br><span class="line">				:height=&quot;vHeight&quot;</span><br><span class="line">				style=&quot;position: absolute;&quot;</span><br><span class="line">			&gt;&lt;/video&gt;</span><br><span class="line">			&lt;canvas </span><br><span class="line">				v-if=&quot;isCropper&quot;</span><br><span class="line">				id=&quot;canvasId&quot; </span><br><span class="line">				ref=&quot;canvasId&quot; </span><br><span class="line">				@mousedown=&quot;onMousedown&quot;</span><br><span class="line">				@mouseup=&quot;onMouseup&quot;</span><br><span class="line">				@mousemove=&quot;onMousemove&quot;</span><br><span class="line">				@dblclick=&quot;onDblclick&quot;</span><br><span class="line">				style=&quot;position: absolute;&quot; </span><br><span class="line">				:width=&quot;vWidth&quot; </span><br><span class="line">				:height=&quot;vHeight&quot;</span><br><span class="line">			&gt;&lt;/canvas&gt;</span><br><span class="line">			&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;canvas </span><br><span class="line">			id=&quot;canvasShot&quot; </span><br><span class="line">			ref=&quot;canvasShot&quot; </span><br><span class="line">			style=&quot;display: none;&quot;</span><br><span class="line">			:width=&quot;vWidth&quot; </span><br><span class="line">			:height=&quot;vHeight&quot;</span><br><span class="line">		&gt;&lt;/canvas&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>canvas是用来视频截图用的。</p>
<p>核心js代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	import WebRtcStreamer from &quot;@/utils/webrtcstreamer&quot;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &quot;WebRtcStreamer&quot;,</span><br><span class="line">		props: &#123;</span><br><span class="line">			serveUrl: &#123;</span><br><span class="line">				type: String,</span><br><span class="line">				default: &apos;&apos;</span><br><span class="line">			&#125;,</span><br><span class="line">			rtspUrl: &#123;</span><br><span class="line">				type: String,</span><br><span class="line">				default: &apos;&apos;</span><br><span class="line">			&#125;,</span><br><span class="line">			vWidth: &#123;</span><br><span class="line">				type: Number,</span><br><span class="line">				default: 764</span><br><span class="line">			&#125;,</span><br><span class="line">			vHeight: &#123;</span><br><span class="line">				type: Number,</span><br><span class="line">				default: 430</span><br><span class="line">			&#125;,</span><br><span class="line">			isCropper: &#123;</span><br><span class="line">				type: Boolean,</span><br><span class="line">				default: false</span><br><span class="line">			&#125;,</span><br><span class="line">			// index 多个组件必填 否则会只显示一个视频</span><br><span class="line">			index: &#123;</span><br><span class="line">				type: String,</span><br><span class="line">				default: &apos;&apos;</span><br><span class="line">			&#125;,</span><br><span class="line">			strokeColor: &#123;</span><br><span class="line">				type: String,</span><br><span class="line">				default: &apos;#00FF89&apos;</span><br><span class="line">			&#125;,</span><br><span class="line">			// 框选起始位置 边界值</span><br><span class="line">			xLeft: &#123;</span><br><span class="line">				type: Number,</span><br><span class="line">				default: 0</span><br><span class="line">			&#125;,</span><br><span class="line">			yTop: &#123;</span><br><span class="line">				type: Number,</span><br><span class="line">				default: 0</span><br><span class="line">			&#125;,</span><br><span class="line">			// 视频大小与实际比</span><br><span class="line">			xRate: &#123;</span><br><span class="line">				type: Number,</span><br><span class="line">				default: 1</span><br><span class="line">			&#125;,</span><br><span class="line">			yRate: &#123;</span><br><span class="line">				type: Number,</span><br><span class="line">				default: 1</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		data()&#123;  </span><br><span class="line">			return&#123;</span><br><span class="line">				ctx: &apos;&apos;,</span><br><span class="line">				_x1: &apos;&apos;, </span><br><span class="line">				_y1: &apos;&apos;, </span><br><span class="line">				_x2: &apos;&apos;, </span><br><span class="line">				_y2: &apos;&apos;,</span><br><span class="line">				drawing: false,</span><br><span class="line">				picSizeW: &apos;&apos;,</span><br><span class="line">				picSizeH: &apos;&apos;,</span><br><span class="line">				picUrl: &apos;&apos;,</span><br><span class="line">				webRtcServer: null,</span><br><span class="line">				videoName: &apos;&apos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		created()&#123;</span><br><span class="line">			this.videoName = &apos;video&apos;+this.index</span><br><span class="line">		&#125;,</span><br><span class="line">		mounted()&#123;</span><br><span class="line">			this.init()</span><br><span class="line">			if(this.isCropper)&#123;</span><br><span class="line">				this.draw()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		watch: &#123;</span><br><span class="line">			strokeColor()&#123;</span><br><span class="line">				this.draw()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods:&#123;</span><br><span class="line">			init(url)&#123;</span><br><span class="line">				console.log(url,&apos;333&apos;)</span><br><span class="line">				let serveUrl = this.serveUrl || process.env.VUE_APP_WEBRTC_SERVER_URL</span><br><span class="line">				if(this.webRtcServer)&#123;this.webRtcServer.disconnect();&#125;</span><br><span class="line">				this.webRtcServer = new WebRtcStreamer(this.videoName, serveUrl);</span><br><span class="line">				this.webRtcServer.connect(url || this.rtspUrl);</span><br><span class="line">			&#125;,</span><br><span class="line">			draw() &#123;</span><br><span class="line">				const cid = this.$refs.canvasId</span><br><span class="line">				this.ctx = cid.getContext(&quot;2d&quot;)</span><br><span class="line">				this.ctx.lineWidth = 2</span><br><span class="line">				this.ctx.strokeStyle = this.strokeColor</span><br><span class="line">			&#125;,</span><br><span class="line">			// 双击全屏</span><br><span class="line">			onDblclick()&#123;</span><br><span class="line">				// const videoEl = this.$refs[this.videoName]</span><br><span class="line">				// videoEl.requestFullscreen()</span><br><span class="line">			&#125;,</span><br><span class="line">			onMousedown(e)&#123;</span><br><span class="line">				if (this.drawing) &#123;</span><br><span class="line">					this.drawing = false</span><br><span class="line">					return</span><br><span class="line">				&#125;</span><br><span class="line">				this._x1 = e.layerX &lt; this.xLeft ? this.xLeft : e.layerX</span><br><span class="line">				this._y1 = e.layerY &lt; this.yTop ? this.yTop : e.layerY</span><br><span class="line">				this.drawing = true</span><br><span class="line">			&#125;,</span><br><span class="line">			onMouseup(e)&#123;</span><br><span class="line">				this.drawing = false</span><br><span class="line">				if (this._x2 &lt; this._x1) &#123;</span><br><span class="line">					let t = this._x2</span><br><span class="line">					this._x2 = this._x1</span><br><span class="line">					this._x1 = t</span><br><span class="line">				&#125;</span><br><span class="line">				if (this._y2 &lt; this._y1) &#123;</span><br><span class="line">					var t = this._y2</span><br><span class="line">					this._y2 = this._y1</span><br><span class="line">					this._y1 = t</span><br><span class="line">				&#125;</span><br><span class="line">				this.picSizeW = this._x2 - this._x1</span><br><span class="line">				this.picSizeH = this._y2 - this._y1</span><br><span class="line">				if (this.picSizeW &gt; 2 &amp;&amp; this.picSizeH &gt; 2) &#123;</span><br><span class="line">					console.info(&apos;图片宽高均大于2px，认为可以执行截屏操作&apos;)</span><br><span class="line">					this.getShot()</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					this.ctx.clearRect(0, 0, this.vWidth, this.vHeight);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			onMousemove(e)&#123;</span><br><span class="line">				this._x2 = e.layerX &lt; this.xLeft ? this.xLeft : e.layerX</span><br><span class="line">				this._y2 = e.layerY &lt; this.yTop ? this.yTop : e.layerY</span><br><span class="line">				this.render()</span><br><span class="line">			&#125;,</span><br><span class="line">			// 绘制矩形</span><br><span class="line">			render() &#123;</span><br><span class="line">				if (!this.drawing) return</span><br><span class="line">				this.ctx.clearRect(0, 0, this.vWidth, this.vHeight);</span><br><span class="line">				// ctx.drawImage(img, 0, 0, 800, 300)</span><br><span class="line">				this.ctx.fillStyle = &apos;rgba(225,225,225,0.5)&apos;;</span><br><span class="line">				this.ctx.fillRect(0, 0, this.vWidth, this.vHeight);</span><br><span class="line">				let &#123;_x1, _y1, _x2, _y2&#125; = this</span><br><span class="line">				let w = _x2 - _x1</span><br><span class="line">				let h = _y2 - _y1</span><br><span class="line">				this.ctx.clearRect(_x1, _y1, w, h);</span><br><span class="line">				this.ctx.strokeRect(_x1, _y1, w, h);</span><br><span class="line">			&#125;,</span><br><span class="line">			// 绘制新canvas并生成图片</span><br><span class="line">			getShot() &#123;</span><br><span class="line">				const canvasShotId = this.$refs.canvasShot</span><br><span class="line">				const csId_ctx = canvasShotId.getContext(&apos;2d&apos;)</span><br><span class="line">				const vId = this.$refs[this.videoName]</span><br><span class="line">				canvasShotId.width = this.vWidth;</span><br><span class="line">				canvasShotId.height = this.vHeight;</span><br><span class="line">				csId_ctx.drawImage(vId, 0, 0, this.vWidth, this.vHeight)</span><br><span class="line">				let &#123;_x1, _y1, _x2, _y2&#125; = this</span><br><span class="line">				// 获取并存储框选图</span><br><span class="line">				const picSizeW = _x2 - _x1</span><br><span class="line">				const picSizeH = _y2 - _y1</span><br><span class="line">				var imageData = csId_ctx.getImageData(_x1+1, _y1+1, picSizeW-2, picSizeH-2)</span><br><span class="line">				// 重新绘制框选后的整体cancas</span><br><span class="line">				csId_ctx.lineWidth = 2</span><br><span class="line">				csId_ctx.strokeStyle = this.strokeColor</span><br><span class="line">				csId_ctx.fillStyle = &apos;rgba(225,225,225,0.5)&apos;;</span><br><span class="line">				csId_ctx.fillRect(0, 0, this.vWidth, this.vHeight);</span><br><span class="line">				let w = _x2 - _x1</span><br><span class="line">				let h = _y2 - _y1</span><br><span class="line">				csId_ctx.clearRect(_x1, _y1, w, h);</span><br><span class="line">				csId_ctx.strokeRect(_x1, _y1, w, h);</span><br><span class="line">				// 设置框选图标并放到新canvas</span><br><span class="line">				csId_ctx.putImageData(imageData, _x1+1, _y1+1) </span><br><span class="line">				// 新canvas转成图片</span><br><span class="line">				let picUrl = canvasShotId.toDataURL(&apos;image/jpeg&apos;)</span><br><span class="line">				let &#123;xRate,yRate&#125; = this</span><br><span class="line">				let opts = &#123;</span><br><span class="line">					picUrl: picUrl,</span><br><span class="line">					topLeft: [Math.round(_x1*xRate), Math.round(_y1*yRate)],</span><br><span class="line">					topRight: [Math.round(_x2*xRate), Math.round(_y1*yRate)],</span><br><span class="line">					bottomRight: [Math.round(_x2*xRate), Math.round(_y2*yRate)],</span><br><span class="line">					bottomLeft: [Math.round(_x1*xRate), Math.round(_y2*yRate)]</span><br><span class="line">				&#125;</span><br><span class="line">				console.log(opts,&apos;000----&apos;)</span><br><span class="line">				this.$emit(&apos;onchange&apos;, opts)</span><br><span class="line">			&#125;,</span><br><span class="line">			clear()&#123;</span><br><span class="line">				this.ctx.clearRect(0, 0, this.vWidth, this.vHeight);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">		destroyed()&#123;</span><br><span class="line">			this.webRtcServer.disconnect();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>@/utils/webrtcstreamer是组件核心代码可以从git下载，也可以通过npm库里下。</p>
<p>props参数说明<br>serveUrl：rtc服务，最开始启动的8000端口服务地址。<br>rtspUrl：海康摄像头地址rtsp格式。<br>isCropper：是否开始框选截图功能。</p>
<p>直接看init方法初始化链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.webRtcServer = new WebRtcStreamer(this.videoName, serveUrl);</span><br><span class="line">this.webRtcServer.connect(url || this.rtspUrl);</span><br></pre></td></tr></table></figure>

<p>this.videoName是video标签id,因为一个页面有调用多个组件情况所以这里做成动态。</p>
<p>draw()方法是启动canvas视频截图用的。其中代码和逻辑稍多但是不难，可根据实际需求修改。</p>
<p>getShot()方法是把最终截图后的图片url和坐标点以参数形式打印出来给父组件用。</p>
<p>特别注意：海康后台视频设置格式一定改成h264，否则视频显示不出来。</p>
<p>父组件调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;webRtc-streamer</span><br><span class="line">	ref=&quot;cameraRef1&quot;</span><br><span class="line">	rtspUrl=&quot;&quot;</span><br><span class="line">	:vWidth=&quot;764&quot;</span><br><span class="line">	:vHeight=&quot;430&quot;</span><br><span class="line">	:isCropper=&quot;false&quot;</span><br><span class="line">	index=&quot;1&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>磕磕绊绊总算实现了功能，最后部署会发现wertc服务cpu拉满问题，经过测试超过3个人同时访问就会卡死，解决办法是docker启动时候加 -o 。</p>
<p>最后一句话是我的经验很重要：遇到问题发现网上能查到的资料和解决方法并不多，webrtc-streamer遇到问题就去git官网issues里找答案，海康摄像头遇到问题查不到的话就去海康官网找技术客服咨询。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webrtc-streamer</tag>
      </tags>
  </entry>
</search>
